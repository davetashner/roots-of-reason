extends Node2D
## Main prototype scene — assembles map, camera, units, input, and HUD
## programmatically at runtime.

const UnitScript := preload("res://scripts/prototype/prototype_unit.gd")
const ProductionQueueScript := preload("res://scripts/prototype/production_queue.gd")
const AIEconomyScript := preload("res://scripts/ai/ai_economy.gd")
const AIMilitaryScript := preload("res://scripts/ai/ai_military.gd")
const BuildingScript := preload("res://scripts/prototype/prototype_building.gd")

const UNIT_POSITIONS: Array[Vector2i] = [
	Vector2i(3, 3),
	Vector2i(5, 2),
	Vector2i(4, 6),
	Vector2i(7, 4),
	Vector2i(10, 10),
	Vector2i(8, 12),
	Vector2i(15, 8),
	Vector2i(12, 14),
]

var _camera: Camera2D
var _input_handler: Node
var _map_node: Node
var _pathfinder: Node
var _target_detector: Node
var _cursor_overlay: Node
var _building_placer: Node
var _info_panel: PanelContainer
var _population_manager: Node
var _resource_bar: PanelContainer
var _tech_manager: Node
var _war_bonus: Node
var _ai_economy: Node = null
var _ai_military: Node = null


func _ready() -> void:
	_setup_map()
	_setup_camera()
	_setup_pathfinding()
	_setup_target_detection()
	_setup_input()
	_setup_building_placer()
	_setup_population()
	_setup_units()
	_setup_demo_entities()
	_setup_ai()
	_setup_tech()
	_setup_hud()


func _setup_map() -> void:
	var map_layer := TileMapLayer.new()
	map_layer.name = "Map"
	map_layer.set_script(load("res://scripts/map/tilemap_terrain.gd"))
	add_child(map_layer)
	_map_node = map_layer


func _setup_camera() -> void:
	_camera = Camera2D.new()
	_camera.name = "Camera"
	_camera.set_script(load("res://scripts/prototype/prototype_camera.gd"))
	var map_size: int = _map_node.get_map_size()
	var half_size := map_size / 2
	var center := IsoUtils.grid_to_screen(Vector2(half_size, half_size))
	_camera.position = center
	_camera.enabled = true
	add_child(_camera)
	# Compute map bounds from corner grid positions and pass to camera
	var corners: Array[Vector2] = [
		IsoUtils.grid_to_screen(Vector2(0, 0)),
		IsoUtils.grid_to_screen(Vector2(map_size, 0)),
		IsoUtils.grid_to_screen(Vector2(0, map_size)),
		IsoUtils.grid_to_screen(Vector2(map_size, map_size)),
	]
	var min_pos := corners[0]
	var max_pos := corners[0]
	for corner in corners:
		min_pos.x = minf(min_pos.x, corner.x)
		min_pos.y = minf(min_pos.y, corner.y)
		max_pos.x = maxf(max_pos.x, corner.x)
		max_pos.y = maxf(max_pos.y, corner.y)
	var bounds := Rect2(min_pos, max_pos - min_pos)
	_camera.setup(bounds)


func _setup_pathfinding() -> void:
	_pathfinder = Node.new()
	_pathfinder.name = "PathfindingGrid"
	_pathfinder.set_script(load("res://scripts/prototype/pathfinding_grid.gd"))
	add_child(_pathfinder)
	_pathfinder.build(_map_node.get_map_size(), _map_node.get_tile_grid(), {})


func _setup_target_detection() -> void:
	_target_detector = Node.new()
	_target_detector.name = "TargetDetector"
	_target_detector.set_script(load("res://scripts/prototype/target_detector.gd"))
	add_child(_target_detector)


func _setup_input() -> void:
	_input_handler = Node.new()
	_input_handler.name = "InputHandler"
	_input_handler.set_script(load("res://scripts/prototype/prototype_input.gd"))
	add_child(_input_handler)
	if _input_handler.has_method("setup"):
		_input_handler.setup(_camera, _pathfinder, _target_detector)


func _setup_population() -> void:
	_population_manager = Node.new()
	_population_manager.name = "PopulationManager"
	_population_manager.set_script(load("res://scripts/prototype/population_manager.gd"))
	add_child(_population_manager)


func _setup_building_placer() -> void:
	_building_placer = Node.new()
	_building_placer.name = "BuildingPlacer"
	_building_placer.set_script(load("res://scripts/prototype/building_placer.gd"))
	add_child(_building_placer)
	_building_placer.setup(_camera, _pathfinder, _map_node, _target_detector)
	_building_placer.building_placed.connect(_on_building_placed)


func _unhandled_input(event: InputEvent) -> void:
	if event is InputEventKey:
		var key := event as InputEventKey
		if key.pressed and not key.echo and key.keycode == KEY_B:
			if _building_placer != null and not _building_placer.is_active():
				_building_placer.start_placement("house", 0)


func _setup_units() -> void:
	for i in UNIT_POSITIONS.size():
		var unit := Node2D.new()
		unit.name = "Unit_%d" % i
		unit.set_script(UnitScript)
		unit.position = IsoUtils.grid_to_screen(Vector2(UNIT_POSITIONS[i]))
		unit.unit_type = "villager"
		add_child(unit)
		unit._scene_root = self
		# Register with input handler after both are in tree
		if _input_handler.has_method("register_unit"):
			_input_handler.register_unit(unit)
		if _target_detector != null:
			_target_detector.register_entity(unit)
		if _population_manager != null:
			_population_manager.register_unit(unit, 0)


func _setup_demo_entities() -> void:
	# Resource nodes — generated by map system
	var all_resource_positions: Dictionary = _map_node.get_resource_positions()
	var ResourceNodeScript: GDScript = load("res://scripts/prototype/prototype_resource_node.gd")
	var res_index := 0
	for res_name: String in all_resource_positions:
		var positions: Array = all_resource_positions[res_name]
		for pos in positions:
			var grid_pos: Vector2i = pos as Vector2i
			var res_node := Node2D.new()
			res_node.name = "Resource_%s_%d" % [res_name, res_index]
			res_node.set_script(ResourceNodeScript)
			res_node.position = IsoUtils.grid_to_screen(Vector2(grid_pos))
			add_child(res_node)
			res_node.setup(res_name)
			res_node.depleted.connect(_on_resource_depleted)
			_target_detector.register_entity(res_node)
			res_index += 1
	# Own building (blue, 3x3 town center) — fully built
	var building := Node2D.new()
	building.name = "Building_0"
	building.set_script(BuildingScript)
	var bld_pos := Vector2i(4, 4)
	building.position = IsoUtils.grid_to_screen(Vector2(bld_pos))
	building.owner_id = 0
	building.building_name = "town_center"
	building.footprint = Vector2i(3, 3)
	building.grid_pos = bld_pos
	building.hp = 2400
	building.max_hp = 2400
	building.under_construction = false
	building.build_progress = 1.0
	add_child(building)
	_target_detector.register_entity(building)
	if _population_manager != null:
		_population_manager.register_building(building, building.owner_id)
	_try_attach_production_queue(building)
	# Mark footprint cells solid
	var cells := BuildingValidator.get_footprint_cells(bld_pos, Vector2i(3, 3))
	for cell in cells:
		_pathfinder.set_cell_solid(cell, true)


func _on_building_placed(building: Node2D) -> void:
	if building.has_signal("construction_complete"):
		building.construction_complete.connect(_on_building_construction_complete)
	var idle_unit := _find_nearest_idle_unit(building.global_position)
	if idle_unit != null and idle_unit.has_method("assign_build_target"):
		idle_unit.assign_build_target(building)


func _on_building_construction_complete(building: Node2D) -> void:
	if _population_manager != null and "owner_id" in building:
		_population_manager.register_building(building, building.owner_id)
	_try_attach_production_queue(building)


func _setup_ai() -> void:
	ResourceManager.init_player(1)
	var ai_tc := _create_ai_town_center()
	_create_ai_starting_villagers(ai_tc, 3)
	_ai_economy = Node.new()
	_ai_economy.name = "AIEconomy"
	_ai_economy.set_script(AIEconomyScript)
	add_child(_ai_economy)
	_ai_economy.setup(self, _population_manager, _pathfinder, _map_node, _target_detector)
	_ai_military = Node.new()
	_ai_military.name = "AIMilitary"
	_ai_military.set_script(AIMilitaryScript)
	add_child(_ai_military)
	_ai_military.setup(self, _population_manager, _target_detector, _ai_economy)


func _create_ai_town_center() -> Node2D:
	var map_size: int = _map_node.get_map_size()
	var tc_pos := Vector2i(map_size - 7, map_size - 7)
	var building := Node2D.new()
	building.name = "AI_TownCenter"
	building.set_script(BuildingScript)
	building.position = IsoUtils.grid_to_screen(Vector2(tc_pos))
	building.owner_id = 1
	building.building_name = "town_center"
	building.footprint = Vector2i(3, 3)
	building.grid_pos = tc_pos
	building.hp = 2400
	building.max_hp = 2400
	building.under_construction = false
	building.build_progress = 1.0
	building.entity_category = "enemy_building"
	add_child(building)
	_target_detector.register_entity(building)
	if _population_manager != null:
		_population_manager.register_building(building, building.owner_id)
	_try_attach_production_queue(building)
	# Mark footprint cells solid
	var cells := BuildingValidator.get_footprint_cells(tc_pos, Vector2i(3, 3))
	for cell in cells:
		_pathfinder.set_cell_solid(cell, true)
	return building


func _create_ai_starting_villagers(tc: Node2D, count: int) -> void:
	var offsets: Array[Vector2i] = [Vector2i(-1, 0), Vector2i(0, -1), Vector2i(-1, -1)]
	for i in count:
		var unit := Node2D.new()
		unit.name = "AIVillager_%d" % i
		unit.set_script(UnitScript)
		unit.unit_type = "villager"
		unit.owner_id = 1
		unit.unit_color = Color(0.9, 0.2, 0.2)
		var offset := offsets[i % offsets.size()]
		var spawn_pos: Vector2i = tc.grid_pos + offset
		unit.position = IsoUtils.grid_to_screen(Vector2(spawn_pos))
		add_child(unit)
		unit._scene_root = self
		if _target_detector != null:
			_target_detector.register_entity(unit)
		if _population_manager != null:
			_population_manager.register_unit(unit, 1)


func _find_nearest_idle_unit(target_pos: Vector2) -> Node2D:
	var best: Node2D = null
	var best_dist := INF
	for child in get_children():
		if not child.has_method("is_idle"):
			continue
		if "owner_id" in child and child.owner_id != 0:
			continue
		if not child.is_idle():
			continue
		var dist: float = child.global_position.distance_to(target_pos)
		if dist < best_dist:
			best_dist = dist
			best = child
	return best


func _try_attach_production_queue(building: Node2D) -> void:
	if not "building_name" in building:
		return
	var building_name: String = building.building_name
	if building_name == "":
		return
	var stats: Dictionary = DataLoader.get_building_stats(building_name)
	var units_produced: Array = stats.get("units_produced", [])
	if units_produced.is_empty():
		return
	var pq := Node.new()
	pq.name = "ProductionQueue"
	pq.set_script(ProductionQueueScript)
	building.add_child(pq)
	var owner_id: int = building.owner_id if "owner_id" in building else 0
	pq.setup(building, owner_id, _population_manager)
	pq.unit_produced.connect(_on_unit_produced)


func _on_unit_produced(unit_type: String, building: Node2D) -> void:
	var unit := Node2D.new()
	var unit_count := get_child_count()
	unit.name = "Unit_%d" % unit_count
	unit.set_script(UnitScript)
	unit.unit_type = unit_type
	var owner_id: int = building.owner_id if "owner_id" in building else 0
	unit.owner_id = owner_id
	# Spawn at building position offset by rally point
	var pq: Node = building.get_node_or_null("ProductionQueue")
	var offset := Vector2i(1, 1)
	if pq != null and pq.has_method("get_rally_point_offset"):
		offset = pq.get_rally_point_offset()
	var spawn_grid: Vector2i = Vector2i.ZERO
	if "grid_pos" in building:
		spawn_grid = building.grid_pos + offset
	unit.position = IsoUtils.grid_to_screen(Vector2(spawn_grid))
	add_child(unit)
	unit._scene_root = self
	if _input_handler != null and _input_handler.has_method("register_unit"):
		_input_handler.register_unit(unit)
	if _target_detector != null:
		_target_detector.register_entity(unit)
	if _population_manager != null:
		_population_manager.register_unit(unit, owner_id)


func _on_resource_depleted(node: Node2D) -> void:
	if _target_detector != null and _target_detector.has_method("unregister_entity"):
		_target_detector.unregister_entity(node)


func _setup_tech() -> void:
	_tech_manager = Node.new()
	_tech_manager.name = "TechManager"
	_tech_manager.set_script(load("res://scripts/prototype/tech_manager.gd"))
	add_child(_tech_manager)
	# War research bonus node — tracks combat state and provides speed multiplier
	_war_bonus = Node.new()
	_war_bonus.name = "WarResearchBonus"
	_war_bonus.set_script(load("res://scripts/prototype/war_research_bonus.gd"))
	add_child(_war_bonus)
	_tech_manager.setup_war_bonus(_war_bonus)
	# Connect tech completion to spillover system
	_tech_manager.tech_researched.connect(_on_tech_researched_spillover)


func _setup_hud() -> void:
	var hud := CanvasLayer.new()
	hud.name = "HUD"
	hud.set_script(load("res://scripts/prototype/prototype_hud.gd"))
	add_child(hud)
	# Connect camera and input handler
	if hud.has_method("setup"):
		hud.setup(_camera, _input_handler)
	# Info panel for selected unit/building details
	var info_panel_layer := CanvasLayer.new()
	info_panel_layer.name = "InfoPanel"
	info_panel_layer.layer = 10
	add_child(info_panel_layer)
	_info_panel = PanelContainer.new()
	_info_panel.name = "InfoPanelWidget"
	_info_panel.set_script(load("res://scripts/ui/info_panel.gd"))
	info_panel_layer.add_child(_info_panel)
	_info_panel.setup(_input_handler)
	# Command panel
	var cmd_panel_layer := CanvasLayer.new()
	cmd_panel_layer.name = "CommandPanel"
	cmd_panel_layer.layer = 10
	add_child(cmd_panel_layer)
	var cmd_panel := PanelContainer.new()
	cmd_panel.name = "CommandPanelWidget"
	cmd_panel.set_script(load("res://scripts/ui/command_panel.gd"))
	cmd_panel_layer.add_child(cmd_panel)
	cmd_panel.setup(_input_handler, _building_placer)
	# Cursor overlay for command context labels
	_cursor_overlay = CanvasLayer.new()
	_cursor_overlay.name = "CursorOverlay"
	_cursor_overlay.set_script(load("res://scripts/prototype/cursor_overlay.gd"))
	add_child(_cursor_overlay)
	_input_handler._cursor_overlay = _cursor_overlay
	# Resource bar HUD
	_setup_resource_bar()


func _setup_resource_bar() -> void:
	ResourceManager.init_player(0)
	var resource_bar_layer := CanvasLayer.new()
	resource_bar_layer.name = "ResourceBar"
	resource_bar_layer.layer = 10
	add_child(resource_bar_layer)
	_resource_bar = PanelContainer.new()
	_resource_bar.name = "ResourceBarPanel"
	_resource_bar.set_script(load("res://scripts/ui/resource_bar.gd"))
	resource_bar_layer.add_child(_resource_bar)
	# Connect population manager to resource bar display
	if _population_manager != null:
		_population_manager.population_changed.connect(_on_population_changed)
		# Initial display update
		var current: int = _population_manager.get_population(0)
		var cap: int = _population_manager.get_population_cap(0)
		_resource_bar.update_population(current, cap)


func _on_tech_researched_spillover(player_id: int, tech_id: String, _effects: Dictionary) -> void:
	if _war_bonus != null:
		var tech_data: Dictionary = DataLoader.get_tech_data(tech_id)
		_war_bonus.apply_spillover(player_id, tech_id, tech_data)


func _on_population_changed(player_id: int, current: int, cap: int) -> void:
	if player_id == 0 and _resource_bar != null:
		_resource_bar.update_population(current, cap)
