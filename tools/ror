#!/usr/bin/env bash
# Requires bash 4+ for associative arrays. Install via: brew install bash
# ror — Roots of Reason developer CLI
# Usage: ror <command> [options]
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# --- Colors ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
RESET='\033[0m'

# --- Helpers ---
info()  { printf "${CYAN}▸${RESET} %s\n" "$*"; }
ok()    { printf "${GREEN}✔${RESET} %s\n" "$*"; }
warn()  { printf "${YELLOW}⚠${RESET} %s\n" "$*"; }
err()   { printf "${RED}✖${RESET} %s\n" "$*" >&2; }

# --- Godot binary detection ---
find_godot() {
    if [[ -n "${GODOT_BIN:-}" ]] && [[ -x "$GODOT_BIN" ]]; then
        echo "$GODOT_BIN"
        return
    fi
    # Common locations on macOS
    local candidates=(
        "/Applications/Godot.app/Contents/MacOS/Godot"
        "/Applications/Godot_mono.app/Contents/MacOS/Godot"
        "$HOME/Applications/Godot.app/Contents/MacOS/Godot"
    )
    # Also check PATH
    if command -v godot &>/dev/null; then
        command -v godot
        return
    fi
    for bin in "${candidates[@]}"; do
        if [[ -x "$bin" ]]; then
            echo "$bin"
            return
        fi
    done
    return 1
}

# --- Blender binary detection ---
find_blender() {
    if [[ -n "${BLENDER_BIN:-}" ]] && [[ -x "$BLENDER_BIN" ]]; then
        echo "$BLENDER_BIN"
        return
    fi
    # Common locations on macOS
    local candidates=(
        "/Applications/Blender.app/Contents/MacOS/Blender"
        "$HOME/Applications/Blender.app/Contents/MacOS/Blender"
    )
    # Also check PATH
    if command -v blender &>/dev/null; then
        command -v blender
        return
    fi
    for bin in "${candidates[@]}"; do
        if [[ -x "$bin" ]]; then
            echo "$bin"
            return
        fi
    done
    return 1
}

# --- gdtoolkit venv management ---
VENV_DIR="$PROJECT_ROOT/.venv-gdtoolkit"

ensure_gdtoolkit() {
    if [[ -x "$VENV_DIR/bin/gdlint" ]] && [[ -x "$VENV_DIR/bin/gdformat" ]]; then
        return
    fi
    info "Setting up gdtoolkit virtualenv at $VENV_DIR ..."
    python3 -m venv "$VENV_DIR"
    "$VENV_DIR/bin/pip" install --quiet "gdtoolkit==4.*"
    ok "gdtoolkit installed"
}

# ==================== test ====================

# Map a changed .gd file to its test file path (relative to project root).
# scripts/foo/bar.gd  -> tests/foo/test_bar.gd
# tests/foo/test_x.gd -> tests/foo/test_x.gd (already a test)
# Returns empty string if no mapping exists.
_map_to_test_file() {
    local file="$1"
    if [[ "$file" == tests/* ]]; then
        # Already a test file — include it directly
        if [[ -f "$file" ]]; then
            echo "$file"
        fi
        return
    fi
    if [[ "$file" != scripts/* ]]; then
        return
    fi
    # scripts/foo/bar.gd -> tests/foo/test_bar.gd
    local rel="${file#scripts/}"
    local dir rel_dir base test_path
    dir="$(dirname "$rel")"
    base="$(basename "$rel")"
    if [[ "$dir" == "." ]]; then
        test_path="tests/test_${base}"
    else
        test_path="tests/${dir}/test_${base}"
    fi
    if [[ -f "$test_path" ]]; then
        echo "$test_path"
    fi
}

# Resolve --changed: find test files affected by local changes.
# Prints file paths to stdout (one per line). Info messages go to stderr.
_resolve_changed_tests() {
    local -a test_files=()
    local -a changed_files=()

    # Uncommitted changes (staged + unstaged)
    while IFS= read -r f; do
        [[ -n "$f" ]] && changed_files+=("$f")
    done < <(git diff --name-only HEAD -- '*.gd' 2>/dev/null)

    # Staged but not yet committed
    while IFS= read -r f; do
        [[ -n "$f" ]] && changed_files+=("$f")
    done < <(git diff --cached --name-only -- '*.gd' 2>/dev/null)

    # Changes since merge-base with main (for feature branches)
    local merge_base
    merge_base=$(git merge-base HEAD origin/main 2>/dev/null || echo "")
    if [[ -n "$merge_base" ]]; then
        while IFS= read -r f; do
            [[ -n "$f" ]] && changed_files+=("$f")
        done < <(git diff --name-only "$merge_base" HEAD -- '*.gd' 2>/dev/null)
    fi

    # Deduplicate
    local -A seen=()
    for f in "${changed_files[@]}"; do
        local test_file
        test_file=$(_map_to_test_file "$f")
        if [[ -n "$test_file" ]] && [[ -z "${seen[$test_file]:-}" ]]; then
            seen["$test_file"]=1
            test_files+=("$test_file")
        fi
    done

    if [[ ${#test_files[@]} -eq 0 ]]; then
        warn "No changed test files found — nothing to run" >&2
        return 1
    fi

    info "Running ${#test_files[@]} changed test file(s):" >&2
    for tf in "${test_files[@]}"; do
        printf "  %s\n" "$tf" >&2
    done

    # Output file paths to stdout only
    printf '%s\n' "${test_files[@]}"
}

# Run a single Godot test process with the given --add arguments.
# Usage: _run_godot_tests <godot> <live> <test_args...>
_run_godot_tests() {
    local godot="$1"
    local live="$2"
    shift 2
    local test_args=("$@")

    local godot_flags=("-s")
    if $live; then
        godot_flags+=("-d" "--verbose")
        printf "${BOLD}Running GdUnit4 tests (live) …${RESET}\n"
        info "Godot window will display test scenes — output streams in real time"
        if command -v stdbuf &>/dev/null; then
            stdbuf -oL "$godot" --path . "${godot_flags[@]}" res://addons/gdUnit4/bin/GdUnitCmdTool.gd "${test_args[@]}"
        else
            "$godot" --path . "${godot_flags[@]}" res://addons/gdUnit4/bin/GdUnitCmdTool.gd "${test_args[@]}"
        fi
    else
        godot_flags+=("--headless")
        "$godot" --path . "${godot_flags[@]}" res://addons/gdUnit4/bin/GdUnitCmdTool.gd --ignoreHeadlessMode "${test_args[@]}"
    fi
    return $?
}

# Run tests sharded across N parallel Godot processes.
_run_sharded_tests() {
    local godot="$1"
    local jobs="$2"
    shift 2
    local test_args=("$@")

    # Discover all test files from the provided paths
    local -a all_test_files=()
    local i=0
    while [[ $i -lt ${#test_args[@]} ]]; do
        if [[ "${test_args[$i]}" == "--add" ]]; then
            i=$((i + 1))
            local path="${test_args[$i]}"
            # Convert res:// to filesystem path
            path="${path#res://}"
            if [[ -d "$path" ]]; then
                while IFS= read -r f; do
                    all_test_files+=("$f")
                done < <(find "$path" -name "test_*.gd" -type f | sort)
            elif [[ -f "$path" ]]; then
                all_test_files+=("$path")
            fi
        fi
        i=$((i + 1))
    done

    local total=${#all_test_files[@]}
    if [[ $total -eq 0 ]]; then
        warn "No test files found"
        return 0
    fi

    # Cap jobs at file count
    if [[ $jobs -gt $total ]]; then
        jobs=$total
    fi

    info "Sharding $total test files across $jobs parallel processes"

    # Distribute files round-robin into shard arrays
    local -a pids=()
    local -a shard_logs=()
    local shard_size=$(( (total + jobs - 1) / jobs ))

    for (( j=0; j<jobs; j++ )); do
        local -a shard_args=()
        for (( k=j; k<total; k+=jobs )); do
            shard_args+=("--add" "res://${all_test_files[$k]}")
        done

        if [[ ${#shard_args[@]} -eq 0 ]]; then
            continue
        fi

        local log_file
        log_file=$(mktemp "${TMPDIR:-/tmp}/ror-shard-${j}-XXXXXX.log")
        shard_logs+=("$log_file")

        info "Shard $((j+1))/$jobs: ${#shard_args[@]} args ($(( ${#shard_args[@]} / 2 )) files)"

        (
            "$godot" --path . -s --headless \
                res://addons/gdUnit4/bin/GdUnitCmdTool.gd \
                --ignoreHeadlessMode \
                -rd "reports/shard_${j}" \
                "${shard_args[@]}" \
                > "$log_file" 2>&1
        ) &
        pids+=($!)
    done

    # Wait for all shards and track exit codes.
    # GdUnit4 exit codes: 0 = pass, 100 = failure, 101 = orphan warning (still pass).
    local worst_exit=0
    local shard_idx=0
    for pid in "${pids[@]}"; do
        local shard_exit=0
        wait "$pid" || shard_exit=$?
        # Treat 101 (orphan warning) as success — same as single-process runner
        local effective_exit=$shard_exit
        if [[ $effective_exit -eq 101 ]]; then
            effective_exit=0
        fi
        if [[ $effective_exit -gt $worst_exit ]]; then
            worst_exit=$effective_exit
        fi
        # Print shard output
        printf "\n${BOLD}── Shard %d/%d (exit %d) ──${RESET}\n" "$((shard_idx+1))" "${#pids[@]}" "$shard_exit"
        # Show only the summary line from each shard
        grep -E "^(Statistics:|Overall Summary:)" "${shard_logs[$shard_idx]}" 2>/dev/null || tail -5 "${shard_logs[$shard_idx]}"
        shard_idx=$((shard_idx + 1))
    done

    # On failure, keep logs for debugging; on success, clean up
    if [[ $worst_exit -gt 0 ]]; then
        for (( si=0; si<${#shard_logs[@]}; si++ )); do
            info "Shard $((si+1)) log: ${shard_logs[$si]}"
        done
    else
        for log in "${shard_logs[@]}"; do
            rm -f "$log"
        done
    fi

    return $worst_exit
}

cmd_test() {
    local godot
    if ! godot=$(find_godot); then
        err "Godot binary not found."
        echo "  Set GODOT_BIN or install Godot to a standard location."
        exit 1
    fi
    info "Using Godot: $godot"

    local live=false
    local changed=false
    local jobs=0
    local test_args=()
    local raw_args=()

    # Parse flags
    for arg in "$@"; do
        case "$arg" in
            --live)    live=true ;;
            --changed) changed=true ;;
            --jobs=*)  jobs="${arg#--jobs=}" ;;
            --jobs)    err "--jobs requires a value (e.g., --jobs=4)"; exit 1 ;;
            *)         raw_args+=("$arg") ;;
        esac
    done

    cd "$PROJECT_ROOT"

    # Handle --changed: resolve affected test files
    if $changed; then
        local -a changed_files=()
        while IFS= read -r f; do
            [[ -n "$f" ]] && changed_files+=("$f")
        done < <(_resolve_changed_tests)

        if [[ ${#changed_files[@]} -eq 0 ]]; then
            return 0
        fi

        for tf in "${changed_files[@]}"; do
            raw_args+=("$tf")
        done
    fi

    # Build GdUnit4 --add arguments
    if [[ ${#raw_args[@]} -gt 0 ]]; then
        for arg in "${raw_args[@]}"; do
            if [[ "$arg" == tests/* ]] || [[ "$arg" == ./tests/* ]]; then
                arg="${arg#./}"
                test_args+=("--add" "res://$arg")
            elif [[ "$arg" == res://* ]]; then
                test_args+=("--add" "$arg")
            else
                test_args+=("$arg")
            fi
        done
    else
        test_args=("--add" "res://tests")
    fi

    # Ensure .godot cache is fresh (needed for class resolution)
    info "Importing project resources ..."
    "$godot" --headless --path . --import >/dev/null 2>&1 || true

    local exit_code=0

    if [[ $jobs -gt 1 ]]; then
        printf "${BOLD}Running GdUnit4 tests (${jobs} parallel shards) …${RESET}\n"
        _run_sharded_tests "$godot" "$jobs" "${test_args[@]}" || exit_code=$?
    else
        printf "${BOLD}Running GdUnit4 tests …${RESET}\n"
        _run_godot_tests "$godot" "$live" "${test_args[@]}" || exit_code=$?
    fi

    # Copy logs silently (skip for sharded runs — each shard writes its own)
    if [[ $jobs -le 1 ]]; then
        "$godot" --headless --path . --quiet -s res://addons/gdUnit4/bin/GdUnitCopyLog.gd "${test_args[@]}" >/dev/null 2>&1 || true
    fi

    echo ""
    if [[ $exit_code -eq 0 ]]; then
        ok "All tests passed"
    else
        err "Tests failed (exit code $exit_code)"
    fi
    return $exit_code
}

# ==================== lint ====================
cmd_lint() {
    ensure_gdtoolkit
    local gdlint="$VENV_DIR/bin/gdlint"
    local gdformat="$VENV_DIR/bin/gdformat"
    local fix=false
    local targets=("scripts/" "tests/")

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --fix) fix=true; shift ;;
            *)     targets=("$@"); break ;;
        esac
    done

    cd "$PROJECT_ROOT"
    local exit_code=0

    if $fix; then
        info "Auto-formatting with gdformat ..."
        "$gdformat" "${targets[@]}" || true
        ok "Formatting complete"
    fi

    printf "${BOLD}Running gdlint …${RESET}\n"
    if "$gdlint" "${targets[@]}"; then
        ok "Lint passed"
    else
        err "Lint issues found"
        exit_code=1
    fi

    if ! $fix; then
        printf "${BOLD}Checking format …${RESET}\n"
        if "$gdformat" --check "${targets[@]}"; then
            ok "Format check passed"
        else
            warn "Format issues found — run 'ror lint --fix' to auto-format"
            exit_code=1
        fi
    fi

    return $exit_code
}

# ==================== coverage ====================
cmd_coverage() {
    local threshold=90
    local json=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --threshold) threshold="$2"; shift 2 ;;
            --json)      json=true; shift ;;
            *)           err "Unknown coverage option: $1"; exit 1 ;;
        esac
    done

    cd "$PROJECT_ROOT"

    # Collect all .gd files under scripts/
    local -a scripts=()
    while IFS= read -r -d '' f; do
        scripts+=("$f")
    done < <(find scripts/ -name '*.gd' -print0 2>/dev/null | sort -z)

    local total=${#scripts[@]}
    if [[ $total -eq 0 ]]; then
        if $json; then
            printf '{"total":0,"covered":0,"uncovered":0,"percentage":100,"threshold":%d,"pass":true,"uncovered_files":[]}\n' "$threshold"
        else
            ok "No scripts found — nothing to cover"
        fi
        return 0
    fi

    local covered=0
    local -a uncovered=()
    local -a covered_files=()

    for script in "${scripts[@]}"; do
        # scripts/foo/bar.gd → tests/foo/test_bar.gd
        local dir rel_dir base test_path
        dir="$(dirname "$script")"
        rel_dir="${dir#scripts}"
        rel_dir="${rel_dir#/}"
        base="$(basename "$script")"
        if [[ -n "$rel_dir" ]]; then
            test_path="tests/${rel_dir}/test_${base}"
        else
            test_path="tests/test_${base}"
        fi

        if [[ -f "$test_path" ]]; then
            covered=$((covered + 1))
            covered_files+=("$script")
        else
            uncovered+=("$script")
        fi
    done

    local pct=$(( (covered * 100) / total ))
    local pass=true
    if [[ $pct -lt $threshold ]]; then
        pass=false
    fi

    if $json; then
        # Build JSON output
        local uncov_json="["
        local first=true
        for f in "${uncovered[@]}"; do
            if $first; then first=false; else uncov_json+=","; fi
            uncov_json+="\"$f\""
        done
        uncov_json+="]"
        printf '{"total":%d,"covered":%d,"uncovered":%d,"percentage":%d,"threshold":%d,"pass":%s,"uncovered_files":%s}\n' \
            "$total" "$covered" "$((total - covered))" "$pct" "$threshold" "$pass" "$uncov_json"
    else
        printf "${BOLD}Test-file presence report${RESET}\n"
        printf "Checks whether each script in scripts/ has a corresponding test file in tests/.\n"
        echo ""
        if [[ ${#uncovered[@]} -gt 0 ]]; then
            printf "${YELLOW}Uncovered scripts (no matching test file):${RESET}\n"
            for f in "${uncovered[@]}"; do
                printf "  ${RED}✗${RESET} %s\n" "$f"
            done
            echo ""
        fi
        if [[ ${#covered_files[@]} -gt 0 ]]; then
            printf "${GREEN}Covered scripts:${RESET}\n"
            for f in "${covered_files[@]}"; do
                printf "  ${GREEN}✔${RESET} %s\n" "$f"
            done
            echo ""
        fi
        printf "Test-file presence: ${BOLD}%d/%d (%d%%)${RESET}  Threshold: %d%%\n" "$covered" "$total" "$pct" "$threshold"
        echo ""
        if $pass; then
            ok "Test-file presence gate passed"
        else
            err "Test-file presence gate failed — ${pct}% < ${threshold}% threshold"
            return 1
        fi
    fi

    if ! $pass; then
        return 1
    fi
    return 0
}

# ==================== scaffold ====================
cmd_scaffold() {
    if [[ $# -lt 1 ]]; then
        err "Usage: ror scaffold <path/name> [--type Node2D]"
        echo "  Example: ror scaffold map/pathfinder"
        echo "  Example: ror scaffold ui/minimap --type Control"
        exit 1
    fi

    local feature_path="$1"
    shift
    local base_type="Node2D"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --type) base_type="$2"; shift 2 ;;
            *)      err "Unknown scaffold option: $1"; exit 1 ;;
        esac
    done

    # Derive names from path
    local dir_part name
    dir_part="$(dirname "$feature_path")"
    name="$(basename "$feature_path")"

    # PascalCase from snake_case
    local pascal_name=""
    IFS='_' read -ra parts <<< "$name"
    for part in "${parts[@]}"; do
        pascal_name+="$(tr '[:lower:]' '[:upper:]' <<< "${part:0:1}")${part:1}"
    done

    # Build file paths
    local scene_dir script_dir test_dir
    if [[ "$dir_part" == "." ]]; then
        scene_dir="$PROJECT_ROOT/scenes"
        script_dir="$PROJECT_ROOT/scripts"
        test_dir="$PROJECT_ROOT/tests"
    else
        scene_dir="$PROJECT_ROOT/scenes/$dir_part"
        script_dir="$PROJECT_ROOT/scripts/$dir_part"
        test_dir="$PROJECT_ROOT/tests/$dir_part"
    fi

    local scene_file="$scene_dir/${name}.tscn"
    local script_file="$script_dir/${name}.gd"
    local test_file="$test_dir/test_${name}.gd"

    # Refuse to overwrite
    local conflict=false
    for f in "$scene_file" "$script_file" "$test_file"; do
        if [[ -f "$f" ]]; then
            err "File already exists: $f"
            conflict=true
        fi
    done
    if $conflict; then
        exit 1
    fi

    # Build res:// path for script reference
    local res_script_path
    if [[ "$dir_part" == "." ]]; then
        res_script_path="res://scripts/${name}.gd"
    else
        res_script_path="res://scripts/${dir_part}/${name}.gd"
    fi

    # Create directories
    mkdir -p "$scene_dir" "$script_dir" "$test_dir"

    # Write scene file
    cat > "$scene_file" <<TSCN
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="${res_script_path}" id="1"]

[node name="${pascal_name}" type="${base_type}"]
script = ExtResource("1")
TSCN

    # Write script file
    cat > "$script_file" <<GDSCRIPT
extends ${base_type}
## TODO: describe ${pascal_name}.
GDSCRIPT

    # Write test file
    cat > "$test_file" <<GDTEST
extends GdUnitTestSuite
## Tests for ${pascal_name}.


func test_placeholder() -> void:
	assert_bool(true).is_true()
GDTEST

    ok "Created: $scene_file"
    ok "Created: $script_file"
    ok "Created: $test_file"
}

# ==================== new-test ====================
cmd_new_test() {
    if [[ $# -lt 1 ]]; then
        err "Usage: ror new-test <script.gd>"
        echo "  Example: ror new-test scripts/autoloads/resource_manager.gd"
        exit 1
    fi

    local source_path="$1"

    # Resolve relative to project root
    cd "$PROJECT_ROOT"

    # Validate source file exists
    if [[ ! -f "$source_path" ]]; then
        err "Source file not found: $source_path"
        exit 1
    fi

    # Validate it lives under scripts/
    if [[ "$source_path" != scripts/* ]]; then
        err "Source file must be under scripts/ (got: $source_path)"
        exit 1
    fi

    # Derive test path: scripts/foo/bar.gd -> tests/foo/test_bar.gd
    local rel_path="${source_path#scripts/}"
    local dir_part base test_dir test_path
    dir_part="$(dirname "$rel_path")"
    base="$(basename "$rel_path")"

    if [[ "$dir_part" == "." ]]; then
        test_dir="tests"
    else
        test_dir="tests/$dir_part"
    fi
    test_path="${test_dir}/test_${base}"

    # Refuse to overwrite existing test files
    if [[ -f "$test_path" ]]; then
        err "Test file already exists: $test_path"
        exit 1
    fi

    # Extract class_name (if declared) or derive PascalCase from filename
    local class_name=""
    class_name=$(grep -m1 '^class_name ' "$source_path" | sed 's/^class_name //' | tr -d '[:space:]' || true)
    if [[ -z "$class_name" ]]; then
        # Convert snake_case filename to PascalCase
        local name_no_ext="${base%.gd}"
        class_name=""
        IFS='_' read -ra parts <<< "$name_no_ext"
        for part in "${parts[@]}"; do
            class_name+="$(tr '[:lower:]' '[:upper:]' <<< "${part:0:1}")${part:1}"
        done
    fi

    # Extract public function names (lines starting with "func " where the
    # function name does NOT begin with "_")
    local -a funcs=()
    while IFS= read -r line; do
        # Extract function name from "func name(..." pattern
        local fname
        fname=$(echo "$line" | sed -n 's/^func \([a-zA-Z][a-zA-Z0-9_]*\).*/\1/p')
        if [[ -n "$fname" ]]; then
            funcs+=("$fname")
        fi
    done < <(grep '^func [^_]' "$source_path")

    # Create intermediate directories
    mkdir -p "$test_dir"

    # Write the test file
    {
        printf 'extends GdUnitTestSuite\n'
        printf '## Tests for %s.\n' "$class_name"

        if [[ ${#funcs[@]} -eq 0 ]]; then
            printf '\n\n'
            printf 'func test_placeholder() -> void:\n'
            printf '\tassert_bool(true).is_true()\n'
        else
            for fname in "${funcs[@]}"; do
                printf '\n\n'
                printf 'func test_%s() -> void:\n' "$fname"
                printf '\tassert_bool(true).is_true()\n'
            done
        fi
    } > "$test_path"

    ok "Created: $test_path"
    info "Found ${#funcs[@]} public function(s) in $source_path"
    if [[ ${#funcs[@]} -gt 0 ]]; then
        for fname in "${funcs[@]}"; do
            printf "  test_%s\n" "$fname"
        done
    fi
}

# ==================== gen-sprites ====================

# Registry of sprite categories → generator scripts.
# Add new entries here as generators are created.
ALL_SPRITE_CATEGORIES="tiles"

generator_for() {
    case "$1" in
        tiles) echo "tools/generate_prototype_tiles.py" ;;
        *)     return 1 ;;
    esac
}

cmd_gen_sprites() {
    cd "$PROJECT_ROOT"

    # Determine which categories to run
    local -a categories=()
    if [[ $# -eq 0 ]]; then
        # No argument — run all generators
        for cat in $ALL_SPRITE_CATEGORIES; do
            categories+=("$cat")
        done
    else
        for cat in "$@"; do
            if ! generator_for "$cat" >/dev/null 2>&1; then
                err "Unknown sprite category: $cat"
                echo "  Available categories: $ALL_SPRITE_CATEGORIES"
                exit 1
            fi
            categories+=("$cat")
        done
    fi

    local total=${#categories[@]}
    local passed=0
    local failed=0
    local overall_start=$SECONDS

    local label="categories"
    [[ $total -eq 1 ]] && label="category"
    printf "${BOLD}Generating sprites (%d %s) …${RESET}\n" "$total" "$label"

    for cat in "${categories[@]}"; do
        local script
        script="$(generator_for "$cat")"
        local start=$SECONDS

        info "[$cat] Running $script ..."
        if python3 "$script"; then
            local elapsed=$(( SECONDS - start ))
            ok "[$cat] Done (${elapsed}s)"
            passed=$((passed + 1))
        else
            local elapsed=$(( SECONDS - start ))
            err "[$cat] Failed (${elapsed}s)"
            failed=$((failed + 1))
        fi
    done

    local overall_elapsed=$(( SECONDS - overall_start ))
    echo ""
    printf "${BOLD}Sprite generation complete${RESET} — %d passed, %d failed (%ds total)\n" \
        "$passed" "$failed" "$overall_elapsed"

    if [[ $failed -gt 0 ]]; then
        err "Some generators failed"
        return 1
    fi
    ok "All sprites generated"
    return 0
}

# ==================== split-sprites ====================
cmd_split_sprites() {
    cd "$PROJECT_ROOT"
    python3 "$SCRIPT_DIR/split_spritesheet.py" "$@"
}

# ==================== scene-tree ====================
cmd_scene_tree() {
    cd "$PROJECT_ROOT"
    python3 "$SCRIPT_DIR/scene_tree.py" "$@"
}

# ==================== process-sprite ====================
cmd_process_sprite() {
    cd "$PROJECT_ROOT"
    python3 "$SCRIPT_DIR/process_sprite.py" "$@"
}

# ==================== blender-render ====================
cmd_blender_render() {
    local blender
    blender=$(find_blender) || {
        err "Blender not found. Set BLENDER_BIN or install Blender."
        exit 1
    }
    cd "$PROJECT_ROOT"
    info "Using Blender: $blender"
    "$blender" --background --python "$PROJECT_ROOT/blender/render_isometric.py" -- "$@"
}

# ==================== blender-archer ====================
cmd_blender_archer() {
    local blender
    blender=$(find_blender) || {
        err "Blender not found. Set BLENDER_BIN or install Blender."
        exit 1
    }
    cd "$PROJECT_ROOT"

    local subject="archer"
    local animations="idle,walk,attack,death"
    local frames="4,8,6,6"

    info "Step 1/2: Rendering geometric archer in Blender ..."
    "$blender" --background --python "$PROJECT_ROOT/blender/render_isometric.py" -- \
        "$subject" --type unit \
        --animations "$animations" \
        --frames-per-anim "$frames"

    info "Step 2/2: Generating manifest + sprite config ..."
    python3 "$PROJECT_ROOT/blender/generate_manifest.py" "$subject"

    ok "Archer pipeline complete"
    info "Rendered frames: blender/renders/$subject/"
    info "Game sprites:    assets/sprites/units/$subject/"
    info "Manifest:        assets/sprites/units/$subject/manifest.json"
    info "Sprite config:   data/units/sprites/$subject.json"
}

# ==================== sprite-sheet ====================
cmd_sprite_sheet() {
    cd "$PROJECT_ROOT"
    python3 "$SCRIPT_DIR/sprite_sheet.py" "$@"
}

# ==================== pack-sprites ====================
cmd_pack_sprites() {
    cd "$PROJECT_ROOT"
    python3 "$SCRIPT_DIR/spritesheet_packer.py" "$@"
}

# ==================== asset-pipeline ====================
cmd_asset_pipeline() {
    cd "$PROJECT_ROOT"
    python3 "$SCRIPT_DIR/asset_pipeline.py" "$@"
}

# ==================== animate ====================
cmd_animate() {
    cd "$PROJECT_ROOT"
    python3 "$SCRIPT_DIR/animate.py" "$@"
}

# ==================== validate-assets ====================
cmd_validate_assets() {
    cd "$PROJECT_ROOT"
    info "Validating assets against ADR-008 rules ..."
    python3 "$SCRIPT_DIR/validate_assets.py" "$@"
    local exit_code=$?
    if [[ $exit_code -eq 0 ]]; then
        ok "Asset validation passed"
    else
        err "Asset validation failed"
    fi
    return $exit_code
}

# ==================== validate-sprites ====================
cmd_validate_sprites() {
    cd "$PROJECT_ROOT"
    info "Validating rendered unit sprites ..."
    python3 "$SCRIPT_DIR/validate_sprites.py" "$@"
    local exit_code=$?
    if [[ $exit_code -eq 0 ]]; then
        ok "Sprite validation passed"
    else
        err "Sprite validation failed"
    fi
    return $exit_code
}

# ==================== data-check ====================
cmd_data_check() {
    cd "$PROJECT_ROOT"
    printf "${BOLD}Validating data files against schemas …${RESET}\n"
    python3 "$SCRIPT_DIR/data_check.py" "$@"
}

# ==================== screenshot ====================
cmd_screenshot() {
    local output=""
    local name=""
    local annotate=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --output)   output="$2"; shift 2 ;;
            --name)     name="$2"; shift 2 ;;
            --annotate) annotate="true"; shift ;;
            *)          err "Unknown screenshot option: $1"; exit 1 ;;
        esac
    done

    if [[ -z "$output" ]]; then
        if [[ -z "$name" ]]; then
            name="$(date +%Y%m%d_%H%M%S)"
        fi
        mkdir -p "$PROJECT_ROOT/tests/screenshots"
        output="$PROJECT_ROOT/tests/screenshots/${name}.png"
    fi

    local url="http://127.0.0.1:9222/screenshot"
    if [[ "$annotate" == "true" ]]; then
        url="${url}?annotate=true"
    fi
    curl -s "$url" -o "$output"
    echo "$output"
}

# ==================== game-status ====================
cmd_game_status() {
    curl -s "http://127.0.0.1:9222/status" | python3 -m json.tool
}

# ==================== combat-log ====================
cmd_combat_log() {
    local limit="${1:-20}"
    curl -s "http://127.0.0.1:9222/combat-log?limit=${limit}" | python3 -m json.tool
}

# ==================== economy ====================
cmd_economy() {
    local limit="${1:-10}"
    curl -s "http://127.0.0.1:9222/economy?limit=${limit}" | python3 -m json.tool
}

# ==================== pathfinding ====================
cmd_pathfinding() {
    local query=""
    if [[ $# -gt 0 ]]; then
        query="?unit=$1"
    fi
    curl -s "http://127.0.0.1:9222/pathfinding${query}" | python3 -m json.tool
}

# ==================== perf ====================
cmd_perf() {
    curl -s "http://127.0.0.1:9222/perf" | python3 -m json.tool
}

# ==================== fow ====================
cmd_fow() {
    local player="${1:-0}"
    curl -s "http://127.0.0.1:9222/fow?player=${player}" | python3 -m json.tool
}

# ==================== stop ====================
cmd_stop() {
    # Send stop command to cancel all actions on selected units (or specific unit IDs)
    local json
    if [[ $# -gt 0 ]]; then
        # Build unit_ids array from arguments
        local ids=""
        for uid in "$@"; do
            if [[ -n "$ids" ]]; then
                ids+=", "
            fi
            ids+="\"${uid}\""
        done
        json="{\"action\": \"stop\", \"unit_ids\": [${ids}]}"
    else
        json='{"action": "stop"}'
    fi
    curl -s -X POST -H 'Content-Type: application/json' -d "$json" "http://127.0.0.1:9222/command"
    echo ""
}

# ==================== reset ====================
cmd_reset() {
    curl -s -X POST -H 'Content-Type: application/json' -d '{"action": "reset"}' "http://127.0.0.1:9222/command"
    echo ""
}

# ==================== game-cmd ====================
cmd_game_cmd() {
    if [[ $# -lt 1 ]]; then
        err "Usage: ror game-cmd <action> [key=value ...]"
        exit 1
    fi

    local action="$1"
    shift

    # Build JSON: start with action field
    local json="{\"action\": \"${action}\""
    for arg in "$@"; do
        local key="${arg%%=*}"
        local val="${arg#*=}"
        # Try to detect numeric values
        if [[ "$val" =~ ^-?[0-9]+\.?[0-9]*$ ]]; then
            json+=", \"${key}\": ${val}"
        else
            json+=", \"${key}\": \"${val}\""
        fi
    done
    json+="}"

    curl -s -X POST -H 'Content-Type: application/json' -d "$json" "http://127.0.0.1:9222/command"
    echo ""
}

# ==================== entities ====================
cmd_entities() {
    local query=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --category) query="${query:+$query&}category=$2"; shift 2 ;;
            --type)     query="${query:+$query&}type=$2"; shift 2 ;;
            --owner)    query="${query:+$query&}owner=$2"; shift 2 ;;
            *)          err "Unknown entities option: $1"; exit 1 ;;
        esac
    done

    local url="http://127.0.0.1:9222/entities"
    if [[ -n "$query" ]]; then
        url="${url}?${query}"
    fi

    curl -s "$url" | python3 -m json.tool
}

# ==================== units ====================
cmd_units() {
    local show_all=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --all) show_all=true; shift ;;
            *)     err "Unknown units option: $1"; exit 1 ;;
        esac
    done

    local url="http://127.0.0.1:9222/entities"
    if ! $show_all; then
        url="${url}?category=own_unit"
    fi

    local json
    json=$(curl -sf "$url" 2>/dev/null) || {
        err "Could not connect to debug server at 127.0.0.1:9222"
        echo "  Is the game running with --debug-server?"
        exit 1
    }

    python3 -c "
import sys, json

data = json.loads(sys.argv[1])
entities = data.get('entities', [])
if not entities:
    print('No entities found.')
    sys.exit(0)

# Header
fmt = '%-20s  %-18s  %-16s  %-10s  %s'
print(fmt % ('NAME', 'STATE', 'CARRIED', 'HP', 'POSITION'))
print('-' * 85)

for e in entities:
    name = e.get('name', '?')
    cat = e.get('entity_category', '')

    # State: action for units, category label for non-units
    action = e.get('action', '')
    if action:
        state = action
        gt = e.get('gather_type', '')
        if gt and state in ('gathering', 'moving_to_resource', 'moving_to_drop_off', 'depositing'):
            state += ' ' + gt
    elif cat == 'resource_node':
        rn = e.get('resource_name', e.get('resource_type', ''))
        cy = e.get('current_yield', 0)
        ty = e.get('total_yield', 0)
        state = '%s %d/%d' % (rn, cy, ty)
    elif cat == 'building':
        state = 'building'
        if e.get('under_construction'):
            state = 'constructing'
    else:
        state = cat

    # Carried
    carried_amt = e.get('carried_amount', 0)
    carry_cap = e.get('carry_capacity', 0)
    gather_type = e.get('gather_type', '')
    if carried_amt > 0:
        carried = '%d/%d %s' % (carried_amt, carry_cap, gather_type)
    elif carry_cap > 0:
        carried = '0/%d' % carry_cap
    else:
        carried = ''

    # HP
    hp = e.get('hp', 0)
    max_hp = e.get('max_hp', 0)
    if max_hp > 0:
        hp_str = '%d/%d' % (hp, max_hp)
    else:
        hp_str = ''

    # Position — prefer grid_position, fall back to world position
    gp = e.get('grid_position')
    if gp:
        pos = '(%g, %g)' % (gp['x'], gp['y'])
    else:
        wp = e.get('position', {})
        pos = '(%.0f, %.0f)' % (wp.get('x', 0), wp.get('y', 0))

    print(fmt % (name[:20], state[:18], carried[:16], hp_str[:10], pos))
" "$json"
}

# ==================== wait-until ====================
# Evaluate a condition string against game status JSON.
# Condition format: <field><op><value> where op is >, >=, <, <=, ==, !=
# Fields: any key from /status (wood, food, gold, stone, time) or "idle" for idle unit count.
_eval_condition() {
    local condition="$1"
    local status_json="$2"
    local entities_json="$3"

    # Parse condition: field operator value
    local field op value
    if [[ "$condition" =~ ^([a-z_]+)(>=|<=|!=|==|>|<)([0-9.]+)$ ]]; then
        field="${BASH_REMATCH[1]}"
        op="${BASH_REMATCH[2]}"
        value="${BASH_REMATCH[3]}"
    else
        err "Invalid condition format: $condition"
        echo "  Expected: <field><op><value>  e.g. wood>250, time>=120, idle>3"
        return 2
    fi

    # Extract current value from status JSON
    local current
    case "$field" in
        time)
            current=$(echo "$status_json" | python3 -c "import sys,json; print(json.load(sys.stdin).get('game_time', 0))" 2>/dev/null)
            ;;
        food|wood|gold|stone)
            current=$(echo "$status_json" | python3 -c "import sys,json; print(json.load(sys.stdin).get('player_resources',{}).get('$field', 0))" 2>/dev/null)
            ;;
        idle)
            current=$(echo "$entities_json" | python3 -c "
import sys, json
data = json.load(sys.stdin)
count = sum(1 for e in data.get('entities', []) if e.get('action') == 'idle' and e.get('owner_id', -1) == 0)
print(count)
" 2>/dev/null)
            ;;
        *)
            err "Unknown condition field: $field"
            echo "  Available: food, wood, gold, stone, time, idle"
            return 2
            ;;
    esac

    if [[ -z "$current" ]]; then
        return 1
    fi

    # Compare using python for reliable float comparison
    python3 -c "exit(0 if $current $op $value else 1)" 2>/dev/null
}

cmd_wait_until() {
    if [[ $# -lt 1 ]]; then
        err "Usage: ror wait-until <condition> [--timeout N] [--interval N]"
        echo "  Conditions: wood>250, food>=100, time>120, idle>3"
        echo "  Example: ror wait-until wood>250 --timeout 120"
        exit 1
    fi

    local condition="$1"
    shift
    local timeout=60
    local interval=1

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --timeout)  timeout="$2"; shift 2 ;;
            --interval) interval="$2"; shift 2 ;;
            *)          err "Unknown wait-until option: $1"; exit 1 ;;
        esac
    done

    # Validate condition format before polling
    if ! [[ "$condition" =~ ^[a-z_]+(>=|<=|!=|==|>|<)[0-9.]+$ ]]; then
        err "Invalid condition format: $condition"
        echo "  Expected: <field><op><value>  e.g. wood>250, time>=120, idle>3"
        exit 1
    fi

    info "Waiting for: $condition (timeout ${timeout}s, interval ${interval}s)"

    local start_time=$SECONDS
    local status_json entities_json
    while true; do
        local elapsed=$(( SECONDS - start_time ))
        if [[ $elapsed -ge $timeout ]]; then
            err "Timeout after ${timeout}s — condition not met: $condition"
            # Print final status
            if [[ -n "${status_json:-}" ]]; then
                echo "$status_json" | python3 -m json.tool 2>/dev/null
            fi
            return 1
        fi

        status_json=$(curl -sf "http://127.0.0.1:9222/status" 2>/dev/null || echo "")
        if [[ -z "$status_json" ]]; then
            warn "Debug server not reachable — retrying in ${interval}s"
            sleep "$interval"
            continue
        fi

        # Only fetch entities if condition uses idle count
        entities_json="{}"
        if [[ "$condition" == idle* ]]; then
            entities_json=$(curl -sf "http://127.0.0.1:9222/entities?owner=0" 2>/dev/null || echo "{}")
        fi

        if _eval_condition "$condition" "$status_json" "$entities_json"; then
            ok "Condition met: $condition (${elapsed}s elapsed)"
            echo "$status_json" | python3 -m json.tool 2>/dev/null
            return 0
        fi

        sleep "$interval"
    done
}

# ==================== scenario assertions ====================

# assert <condition> — immediate check (same syntax as wait-until conditions)
_scenario_assert() {
    local condition="$1"
    if [[ -z "$condition" ]]; then
        err "assert requires a condition (e.g. assert food>=100)"
        return 1
    fi

    # Validate condition format
    if ! [[ "$condition" =~ ^[a-z_]+(>=|<=|!=|==|>|<)[0-9.]+$ ]]; then
        err "Invalid assert condition: $condition"
        echo "  Expected: <field><op><value>  e.g. food>=100, wood>250, time>120, idle==0"
        return 1
    fi

    local status_json entities_json
    status_json=$(curl -sf "http://127.0.0.1:9222/status" 2>/dev/null || echo "")
    if [[ -z "$status_json" ]]; then
        err "Assertion failed: could not reach debug server"
        return 1
    fi

    entities_json="{}"
    if [[ "$condition" == idle* ]]; then
        entities_json=$(curl -sf "http://127.0.0.1:9222/entities?owner=0" 2>/dev/null || echo "{}")
    fi

    if _eval_condition "$condition" "$status_json" "$entities_json"; then
        ok "Assertion passed: $condition"
        return 0
    else
        # Extract the actual value for a useful error message
        local field
        field=$(echo "$condition" | sed 's/[><=!].*//')
        local actual
        actual=$(_extract_field_value "$field" "$status_json" "$entities_json")
        err "Assertion failed: $condition (actual: $field=$actual)"
        return 1
    fi
}

# Extract a field's current value from status/entities JSON (for error messages)
_extract_field_value() {
    local field="$1"
    local status_json="$2"
    local entities_json="$3"

    case "$field" in
        time)
            echo "$status_json" | python3 -c "import sys,json; print(json.load(sys.stdin).get('game_time', 0))" 2>/dev/null
            ;;
        food|wood|gold|stone)
            echo "$status_json" | python3 -c "import sys,json; print(json.load(sys.stdin).get('player_resources',{}).get('$field', 0))" 2>/dev/null
            ;;
        idle)
            echo "$entities_json" | python3 -c "
import sys, json
data = json.load(sys.stdin)
count = sum(1 for e in data.get('entities', []) if e.get('action') == 'idle' and e.get('owner_id', -1) == 0)
print(count)
" 2>/dev/null
            ;;
        *)
            echo "?"
            ;;
    esac
}

# assert-count [--category C] [--type T] [--owner N] [--action A] <op> <value>
# Example: assert-count --owner 0 --category villager >= 5
_scenario_assert_count() {
    local args_str="$1"
    if [[ -z "$args_str" ]]; then
        err "assert-count requires filters and a comparison"
        echo "  Usage: assert-count [--category C] [--type T] [--owner N] [--action A] <op> <value>"
        echo "  Example: assert-count --owner 0 --type villager >= 5"
        return 1
    fi

    local -a parts=()
    read -ra parts <<< "$args_str"

    # Separate filters from the trailing operator and value
    local query=""
    local filter_desc=""
    local op="" value=""
    local i=0
    while [[ $i -lt ${#parts[@]} ]]; do
        case "${parts[$i]}" in
            --category)
                query="${query:+$query&}category=${parts[$((i+1))]}"
                filter_desc="${filter_desc:+$filter_desc, }category=${parts[$((i+1))]}"
                i=$((i+2))
                ;;
            --type)
                query="${query:+$query&}type=${parts[$((i+1))]}"
                filter_desc="${filter_desc:+$filter_desc, }type=${parts[$((i+1))]}"
                i=$((i+2))
                ;;
            --owner)
                query="${query:+$query&}owner=${parts[$((i+1))]}"
                filter_desc="${filter_desc:+$filter_desc, }owner=${parts[$((i+1))]}"
                i=$((i+2))
                ;;
            --action)
                # action is filtered client-side since the server doesn't support it
                filter_desc="${filter_desc:+$filter_desc, }action=${parts[$((i+1))]}"
                i=$((i+2))
                ;;
            '>='|'<='|'!='|'=='|'>'|'<')
                op="${parts[$i]}"
                value="${parts[$((i+1))]}"
                i=$((i+2))
                ;;
            *)
                # Try to parse as op+value combined (e.g. ">=5")
                if [[ "${parts[$i]}" =~ ^(>=|<=|!=|==|>|<)([0-9]+)$ ]]; then
                    op="${BASH_REMATCH[1]}"
                    value="${BASH_REMATCH[2]}"
                    i=$((i+1))
                else
                    err "Unknown assert-count argument: ${parts[$i]}"
                    return 1
                fi
                ;;
        esac
    done

    if [[ -z "$op" || -z "$value" ]]; then
        err "assert-count requires an operator and value (e.g. >= 5)"
        return 1
    fi

    local url="http://127.0.0.1:9222/entities"
    if [[ -n "$query" ]]; then
        url="${url}?${query}"
    fi

    local json
    json=$(curl -sf "$url" 2>/dev/null) || {
        err "Assertion failed: could not reach debug server"
        return 1
    }

    # Extract action filter if present
    local action_filter=""
    if [[ "$args_str" == *"--action "* ]]; then
        action_filter=$(echo "$args_str" | sed -n 's/.*--action \([^ ]*\).*/\1/p')
    fi

    local count
    count=$(echo "$json" | python3 -c "
import sys, json
data = json.load(sys.stdin)
entities = data.get('entities', [])
action_filter = '$action_filter'
if action_filter:
    entities = [e for e in entities if e.get('action') == action_filter]
print(len(entities))
" 2>/dev/null)

    if [[ -z "$count" ]]; then
        err "Assertion failed: could not parse entity count"
        return 1
    fi

    if python3 -c "exit(0 if $count $op $value else 1)" 2>/dev/null; then
        ok "Assertion passed: count(${filter_desc:-all}) = $count $op $value"
        return 0
    else
        err "Assertion failed: count(${filter_desc:-all}) = $count, expected $op $value"
        return 1
    fi
}

# assert-no-idle — all player-0 units must have a non-idle action
_scenario_assert_no_idle() {
    local json
    json=$(curl -sf "http://127.0.0.1:9222/entities?owner=0" 2>/dev/null) || {
        err "Assertion failed: could not reach debug server"
        return 1
    }

    local result
    result=$(echo "$json" | python3 -c "
import sys, json
data = json.load(sys.stdin)
entities = data.get('entities', [])
units = [e for e in entities if e.get('entity_category', '') in ('own_unit', 'enemy_unit') or e.get('unit_category', '')]
idle = [e.get('name', '?') for e in units if e.get('action') == 'idle']
if idle:
    print('FAIL:' + ','.join(idle))
else:
    print('OK:' + str(len(units)))
" 2>/dev/null)

    if [[ "$result" == OK:* ]]; then
        local unit_count="${result#OK:}"
        ok "Assertion passed: no idle units ($unit_count active)"
        return 0
    else
        local idle_names="${result#FAIL:}"
        err "Assertion failed: idle units found: $idle_names"
        return 1
    fi
}

# assert-building-at <name> <x> <y> — verify a building exists at grid position
_scenario_assert_building_at() {
    local args_str="$1"
    local bname bx by
    read -r bname bx by <<< "$args_str"

    if [[ -z "$bname" || -z "$bx" || -z "$by" ]]; then
        err "assert-building-at requires NAME X Y"
        echo "  Example: assert-building-at barracks 5 4"
        return 1
    fi

    local json
    json=$(curl -sf "http://127.0.0.1:9222/entities" 2>/dev/null) || {
        err "Assertion failed: could not reach debug server"
        return 1
    }

    local result
    result=$(echo "$json" | python3 -c "
import sys, json
data = json.load(sys.stdin)
name = '$bname'
gx, gy = int('$bx'), int('$by')
for e in data.get('entities', []):
    if e.get('building_name') == name:
        gp = e.get('grid_position', {})
        if gp.get('x') == gx and gp.get('y') == gy:
            hp = e.get('hp', 0)
            max_hp = e.get('max_hp', 0)
            print(f'OK:{hp}/{max_hp}')
            sys.exit(0)
print('FAIL')
" 2>/dev/null)

    if [[ "$result" == OK:* ]]; then
        local hp_info="${result#OK:}"
        ok "Assertion passed: $bname found at ($bx, $by) — HP $hp_info"
        return 0
    else
        err "Assertion failed: no '$bname' building at ($bx, $by)"
        return 1
    fi
}

# assert-entity-hp <name-or-filter> <op> <value>
# Example: assert-entity-hp --type villager > 0
#          assert-entity-hp --name Unit_swordsman_0 >= 50
_scenario_assert_entity_hp() {
    local args_str="$1"
    if [[ -z "$args_str" ]]; then
        err "assert-entity-hp requires filters and a comparison"
        echo "  Usage: assert-entity-hp [--name N] [--type T] [--owner O] <op> <value>"
        echo "  Checks that ALL matching entities satisfy the HP condition."
        return 1
    fi

    local -a parts=()
    read -ra parts <<< "$args_str"

    local name_filter="" type_filter="" owner_filter=""
    local op="" value=""
    local i=0
    while [[ $i -lt ${#parts[@]} ]]; do
        case "${parts[$i]}" in
            --name)
                name_filter="${parts[$((i+1))]}"
                i=$((i+2))
                ;;
            --type)
                type_filter="${parts[$((i+1))]}"
                i=$((i+2))
                ;;
            --owner)
                owner_filter="${parts[$((i+1))]}"
                i=$((i+2))
                ;;
            '>='|'<='|'!='|'=='|'>'|'<')
                op="${parts[$i]}"
                value="${parts[$((i+1))]}"
                i=$((i+2))
                ;;
            *)
                if [[ "${parts[$i]}" =~ ^(>=|<=|!=|==|>|<)([0-9]+)$ ]]; then
                    op="${BASH_REMATCH[1]}"
                    value="${BASH_REMATCH[2]}"
                    i=$((i+1))
                else
                    err "Unknown assert-entity-hp argument: ${parts[$i]}"
                    return 1
                fi
                ;;
        esac
    done

    if [[ -z "$op" || -z "$value" ]]; then
        err "assert-entity-hp requires an operator and value (e.g. > 0)"
        return 1
    fi

    local json
    json=$(curl -sf "http://127.0.0.1:9222/entities" 2>/dev/null) || {
        err "Assertion failed: could not reach debug server"
        return 1
    }

    local result
    result=$(echo "$json" | python3 -c "
import sys, json
data = json.load(sys.stdin)
entities = data.get('entities', [])
name_f = '$name_filter'
type_f = '$type_filter'
owner_f = '$owner_filter'
matched = []
for e in entities:
    if name_f and e.get('name', '') != name_f:
        continue
    if type_f:
        etype = e.get('unit_category', '') or e.get('building_name', '') or e.get('resource_type', '')
        if etype != type_f:
            continue
    if owner_f and e.get('owner_id', -1) != int(owner_f):
        continue
    matched.append(e)
if not matched:
    print('NONE')
    sys.exit(0)
failed = []
for e in matched:
    hp = e.get('hp', 0)
    if not eval(f'{hp} $op $value'):
        failed.append(f\"{e.get('name','?')}={hp}\")
if failed:
    print('FAIL:' + ','.join(failed))
else:
    print('OK:' + str(len(matched)))
" 2>/dev/null)

    if [[ "$result" == "NONE" ]]; then
        err "Assertion failed: no entities matched the filter"
        return 1
    elif [[ "$result" == OK:* ]]; then
        local match_count="${result#OK:}"
        ok "Assertion passed: $match_count entities have HP $op $value"
        return 0
    else
        local failures="${result#FAIL:}"
        err "Assertion failed: HP $op $value not satisfied — $failures"
        return 1
    fi
}

# ==================== scenario ====================
# Execute a single scenario step. Returns 0 on success, 1 on failure.
_run_scenario_step() {
    local step="$1"

    # Trim whitespace
    step="$(echo "$step" | xargs)"
    if [[ -z "$step" ]]; then
        return 0
    fi

    # Parse command and arguments
    local cmd args_str
    cmd="${step%% *}"
    if [[ "$step" == *" "* ]]; then
        args_str="${step#* }"
    else
        args_str=""
    fi

    case "$cmd" in
        select-all)
            cmd_game_cmd "select-all"
            ;;
        gather)
            local gx gy
            read -r gx gy <<< "$args_str"
            if [[ -z "$gx" || -z "$gy" ]]; then
                err "gather requires X Y coordinates"
                return 1
            fi
            cmd_game_cmd "gather" "grid_x=$gx" "grid_y=$gy"
            ;;
        right-click)
            local rx ry
            read -r rx ry <<< "$args_str"
            if [[ -z "$rx" || -z "$ry" ]]; then
                err "right-click requires X Y coordinates"
                return 1
            fi
            cmd_game_cmd "right-click" "grid_x=$rx" "grid_y=$ry"
            ;;
        camera-to)
            local cx cy
            read -r cx cy <<< "$args_str"
            if [[ -z "$cx" || -z "$cy" ]]; then
                err "camera-to requires X Y coordinates"
                return 1
            fi
            cmd_game_cmd "camera-to" "grid_x=$cx" "grid_y=$cy"
            ;;
        speed)
            if [[ -z "$args_str" ]]; then
                err "speed requires a value"
                return 1
            fi
            cmd_game_cmd "speed" "value=$args_str"
            ;;
        pause)
            cmd_game_cmd "pause"
            ;;
        unpause)
            cmd_game_cmd "unpause"
            ;;
        screenshot)
            local screenshot_args=()
            local screenshot_name=""
            local screenshot_annotate=""
            for word in $args_str; do
                if [[ "$word" == "--annotate" ]]; then
                    screenshot_annotate="true"
                elif [[ -z "$screenshot_name" ]]; then
                    screenshot_name="$word"
                fi
            done
            if [[ -n "$screenshot_name" ]]; then
                screenshot_args+=(--name "$screenshot_name")
            fi
            if [[ "$screenshot_annotate" == "true" ]]; then
                screenshot_args+=(--annotate)
            fi
            cmd_screenshot "${screenshot_args[@]}"
            ;;
        wait)
            if [[ -z "$args_str" ]]; then
                err "wait requires a condition (e.g. wait wood>250)"
                return 1
            fi
            # Split args_str to allow --timeout/--interval after condition
            local -a wait_args=()
            read -ra wait_args <<< "$args_str"
            cmd_wait_until "${wait_args[@]}"
            ;;
        sleep)
            if [[ -z "$args_str" ]]; then
                err "sleep requires a duration in seconds"
                return 1
            fi
            info "Sleeping ${args_str}s ..."
            sleep "$args_str"
            ;;
        status)
            cmd_game_status
            ;;
        entities)
            local -a ent_args=()
            if [[ -n "$args_str" ]]; then
                read -ra ent_args <<< "$args_str"
            fi
            cmd_entities "${ent_args[@]}"
            ;;
        spawn)
            # spawn TYPE X Y [OWNER]
            local stype sx sy sowner
            read -r stype sx sy sowner <<< "$args_str"
            if [[ -z "$stype" || -z "$sx" || -z "$sy" ]]; then
                err "spawn requires TYPE X Y [OWNER]"
                return 1
            fi
            local spawn_args=("type=$stype" "grid_x=$sx" "grid_y=$sy")
            if [[ -n "$sowner" ]]; then
                spawn_args+=("owner=$sowner")
            fi
            cmd_game_cmd "spawn" "${spawn_args[@]}"
            ;;
        teleport)
            local tx ty
            read -r tx ty <<< "$args_str"
            if [[ -z "$tx" || -z "$ty" ]]; then
                err "teleport requires X Y coordinates"
                return 1
            fi
            cmd_game_cmd "teleport" "grid_x=$tx" "grid_y=$ty"
            ;;
        place-building)
            # place-building NAME X Y [OWNER] [--under-construction]
            local pb_name pb_x pb_y pb_owner pb_built
            pb_built="true"
            local -a pb_parts=()
            for word in $args_str; do
                if [[ "$word" == "--under-construction" ]]; then
                    pb_built="false"
                else
                    pb_parts+=("$word")
                fi
            done
            pb_name="${pb_parts[0]:-}"
            pb_x="${pb_parts[1]:-}"
            pb_y="${pb_parts[2]:-}"
            pb_owner="${pb_parts[3]:-0}"
            if [[ -z "$pb_name" || -z "$pb_x" || -z "$pb_y" ]]; then
                err "place-building requires NAME X Y [OWNER] [--under-construction]"
                return 1
            fi
            cmd_game_cmd "place-building" "building_name=$pb_name" "grid_x=$pb_x" "grid_y=$pb_y" "owner=$pb_owner" "built=$pb_built"
            ;;
        stop)
            cmd_game_cmd "stop"
            ;;
        assert-count)
            _scenario_assert_count "$args_str"
            ;;
        assert-no-idle)
            _scenario_assert_no_idle
            ;;
        assert-building-at)
            _scenario_assert_building_at "$args_str"
            ;;
        assert-entity-hp)
            _scenario_assert_entity_hp "$args_str"
            ;;
        assert)
            _scenario_assert "$args_str"
            ;;
        set-resources)
            # set-resources food=500 wood=300 gold=200 stone=100
            if [[ -z "$args_str" ]]; then
                err "set-resources requires key=value pairs (e.g. set-resources food=500 wood=300)"
                return 1
            fi
            local -a sr_args=("set-resources")
            for word in $args_str; do
                sr_args+=("$word")
            done
            cmd_game_cmd "${sr_args[@]}"
            ;;
        save)
            local save_slot="${args_str:-debug_scenario}"
            cmd_game_cmd "save" "slot=$save_slot"
            ;;
        load)
            local load_slot="${args_str:-debug_scenario}"
            cmd_game_cmd "load" "slot=$load_slot"
            ;;
        *)
            err "Unknown scenario command: $cmd"
            echo "  Available: select-all, gather X Y, right-click X Y, camera-to X Y,"
            echo "  speed N, pause, unpause, screenshot [NAME], wait CONDITION,"
            echo "  sleep N, status, entities, spawn TYPE X Y [OWNER], teleport X Y,"
            echo "  place-building NAME X Y [OWNER] [--under-construction], stop,"
            echo "  set-resources KEY=VAL ..., save [SLOT], load [SLOT],"
            echo "  assert CONDITION, assert-count FILTERS OP VALUE,"
            echo "  assert-no-idle, assert-building-at NAME X Y, assert-entity-hp FILTER OP VALUE"
            return 1
            ;;
    esac
}

cmd_scenario() {
    if [[ $# -lt 1 ]]; then
        err "Usage: ror scenario <script> | ror scenario --file <path.scenario>"
        echo "  Script: semicolon-separated commands"
        echo "  Example: ror scenario 'select-all; gather 5 4; wait wood>250; screenshot done'"
        exit 1
    fi

    local script=""

    if [[ "$1" == "--file" ]]; then
        if [[ -z "${2:-}" ]]; then
            err "Missing file path after --file"
            exit 1
        fi
        local file_path="$2"
        if [[ ! -f "$file_path" ]]; then
            err "Scenario file not found: $file_path"
            exit 1
        fi
        # Read file, strip comments (#) and blank lines, join with semicolons
        script=$(grep -v '^\s*#' "$file_path" | grep -v '^\s*$' | tr '\n' ';')
    else
        script="$1"
    fi

    # Split on semicolons
    local -a steps=()
    IFS=';' read -ra steps <<< "$script"

    local total=${#steps[@]}
    local step_num=0
    local failed=0

    printf "${BOLD}Running scenario (%d steps) …${RESET}\n" "$total"

    for step in "${steps[@]}"; do
        step="$(echo "$step" | xargs)"
        if [[ -z "$step" ]]; then
            continue
        fi
        step_num=$((step_num + 1))
        printf "\n${CYAN}[%d/%d]${RESET} %s\n" "$step_num" "$total" "$step"

        if _run_scenario_step "$step"; then
            ok "Step $step_num complete"
        else
            err "Step $step_num failed: $step"
            failed=$((failed + 1))
            break
        fi
    done

    echo ""
    if [[ $failed -gt 0 ]]; then
        err "Scenario failed at step $step_num/$total"
        return 1
    fi
    ok "Scenario complete ($step_num steps)"
    return 0
}

# ==================== test-scenarios ====================
cmd_test_scenarios() {
    local godot
    if ! godot=$(find_godot); then
        err "Godot binary not found. Set GODOT_BIN or install Godot."
        exit 1
    fi

    local scenario_dir="$PROJECT_ROOT/tests/scenarios"
    local filter=""
    local timeout=120
    local screenshot_on_fail=true
    local civ="mesopotamia"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --filter)       filter="$2"; shift 2 ;;
            --timeout)      timeout="$2"; shift 2 ;;
            --no-screenshots) screenshot_on_fail=false; shift ;;
            --civ)          civ="$2"; shift 2 ;;
            *)              err "Unknown test-scenarios option: $1"; exit 1 ;;
        esac
    done

    if [[ ! -d "$scenario_dir" ]]; then
        err "Scenario directory not found: $scenario_dir"
        exit 1
    fi

    # Discover scenario files
    local -a scenario_files=()
    while IFS= read -r -d '' f; do
        local basename
        basename="$(basename "$f" .scenario)"
        if [[ -n "$filter" ]] && ! [[ "$basename" == *"$filter"* ]]; then
            continue
        fi
        scenario_files+=("$f")
    done < <(find "$scenario_dir" -name '*.scenario' -print0 | sort -z)

    if [[ ${#scenario_files[@]} -eq 0 ]]; then
        if [[ -n "$filter" ]]; then
            err "No scenario files matching filter '$filter' in $scenario_dir"
        else
            err "No .scenario files found in $scenario_dir"
        fi
        exit 1
    fi

    printf "${BOLD}Found %d scenario(s)${RESET}\n" "${#scenario_files[@]}"

    # Launch Godot with debug server
    info "Launching Godot with debug server ..."
    local godot_log
    godot_log=$(mktemp)
    "$godot" --path "$PROJECT_ROOT" \
        --scene res://scenes/prototype/prototype_main.tscn \
        -- --quick-start "$civ" --debug-server \
        >"$godot_log" 2>&1 &
    local godot_pid=$!

    # Ensure cleanup on exit
    trap '_test_scenarios_cleanup '"$godot_pid"' '"$godot_log" EXIT

    # Wait for debug server to become available
    local server_ready=false
    local wait_start=$SECONDS
    while [[ $(( SECONDS - wait_start )) -lt 30 ]]; do
        if curl -sf "http://127.0.0.1:9222/ping" >/dev/null 2>&1; then
            server_ready=true
            break
        fi
        # Check if Godot crashed
        if ! kill -0 "$godot_pid" 2>/dev/null; then
            err "Godot process exited before debug server was ready"
            echo "--- Godot log ---"
            cat "$godot_log"
            echo "--- end log ---"
            trap - EXIT
            rm -f "$godot_log"
            exit 1
        fi
        sleep 0.5
    done

    if ! $server_ready; then
        err "Debug server did not respond within 30s"
        trap - EXIT
        _test_scenarios_cleanup "$godot_pid" "$godot_log"
        exit 1
    fi
    ok "Debug server ready (PID $godot_pid)"

    # Run scenarios
    local passed=0
    local failed=0
    local skipped=0
    local -a failures=()
    local screenshot_dir="$PROJECT_ROOT/tests/screenshots/scenarios"
    mkdir -p "$screenshot_dir"

    for scenario_file in "${scenario_files[@]}"; do
        local scenario_name
        scenario_name="$(basename "$scenario_file" .scenario)"

        printf "\n${BOLD}━━━ %s ━━━${RESET}\n" "$scenario_name"

        # Reset the scene before each scenario
        curl -sf -X POST -H 'Content-Type: application/json' \
            -d '{"action": "reset"}' "http://127.0.0.1:9222/command" >/dev/null 2>&1 || true

        # Wait for scene to reload after reset
        local reset_wait=0
        while [[ $reset_wait -lt 10 ]]; do
            if curl -sf "http://127.0.0.1:9222/ping" >/dev/null 2>&1; then
                break
            fi
            sleep 0.5
            reset_wait=$((reset_wait + 1))
        done

        # Check Godot is still alive
        if ! kill -0 "$godot_pid" 2>/dev/null; then
            err "Godot process died during scenario: $scenario_name"
            failed=$((failed + 1))
            failures+=("$scenario_name (Godot crashed)")
            break
        fi

        # Run the scenario
        if cmd_scenario --file "$scenario_file" 2>&1; then
            ok "$scenario_name PASSED"
            passed=$((passed + 1))
        else
            err "$scenario_name FAILED"
            failed=$((failed + 1))
            failures+=("$scenario_name")

            # Capture failure screenshot
            if $screenshot_on_fail; then
                local fail_screenshot="$screenshot_dir/${scenario_name}_FAIL.png"
                curl -sf "http://127.0.0.1:9222/screenshot?annotate=true" \
                    -o "$fail_screenshot" 2>/dev/null || true
                if [[ -f "$fail_screenshot" ]]; then
                    info "Failure screenshot: $fail_screenshot"
                fi
            fi
        fi
    done

    # Summary
    echo ""
    printf "${BOLD}═══════════════════════════════════════${RESET}\n"
    printf "${BOLD}Scenario Test Results${RESET}\n"
    printf "${BOLD}═══════════════════════════════════════${RESET}\n"
    printf "  ${GREEN}Passed:${RESET}  %d\n" "$passed"
    if [[ $failed -gt 0 ]]; then
        printf "  ${RED}Failed:${RESET}  %d\n" "$failed"
    else
        printf "  Failed:  0\n"
    fi
    if [[ $skipped -gt 0 ]]; then
        printf "  Skipped: %d\n" "$skipped"
    fi
    printf "  Total:   %d\n" "${#scenario_files[@]}"

    if [[ $failed -gt 0 ]]; then
        echo ""
        printf "${RED}Failures:${RESET}\n"
        for f in "${failures[@]}"; do
            printf "  ${RED}✖${RESET} %s\n" "$f"
        done
        echo ""
        # Don't call exit here — let the trap handle cleanup
        return 1
    fi

    echo ""
    ok "All scenarios passed!"
    return 0
}

_test_scenarios_cleanup() {
    local godot_pid="$1"
    local godot_log="$2"

    if kill -0 "$godot_pid" 2>/dev/null; then
        info "Stopping Godot (PID $godot_pid) ..."
        kill "$godot_pid" 2>/dev/null || true
        # Give it a moment to exit gracefully
        local wait_count=0
        while kill -0 "$godot_pid" 2>/dev/null && [[ $wait_count -lt 10 ]]; do
            sleep 0.5
            wait_count=$((wait_count + 1))
        done
        # Force kill if still alive
        if kill -0 "$godot_pid" 2>/dev/null; then
            kill -9 "$godot_pid" 2>/dev/null || true
        fi
    fi
    rm -f "$godot_log"
}

# ==================== help ====================
cmd_help() {
    cat <<EOF
${BOLD}ror${RESET} — Roots of Reason developer CLI

${BOLD}USAGE${RESET}
  ror <command> [options]

${BOLD}COMMANDS${RESET}
  test [path...] [--live] [--changed] [--jobs=N]
                      Run GdUnit4 tests
                        ror test                    — run all tests
                        ror test tests/autoloads/   — run a subset
                        ror test --live             — stream output in real time
                        ror test tests/ui/ --live   — live subset run
                        ror test --changed          — only test changed files
                        ror test --jobs=4           — run tests in 4 parallel shards
  lint [--fix] [path] Run gdlint + gdformat check
                        ror lint                    — check scripts/ tests/
                        ror lint --fix              — auto-format then lint
  scaffold <path/name> [--type Node2D]
                      Create scene + script + test boilerplate
                        ror scaffold map/pathfinder
                        ror scaffold ui/minimap --type Control
  new-test <script.gd> Generate a GdUnit4 test file for a source script
                        ror new-test scripts/autoloads/resource_manager.gd
  coverage [options]  Test-file presence gate (checks each script has a test file)
                        ror coverage                — check at 90% threshold
                        ror coverage --threshold 90 — custom threshold
                        ror coverage --json         — machine-readable output
                      NOTE: This checks test FILE existence, not line/branch coverage.
  gen-sprites [cat..] Generate placeholder sprite assets
                        ror gen-sprites             — generate all categories
                        ror gen-sprites tiles       — generate only tiles
  scene-tree <file.tscn> [--depth N]
                      Print the node tree of a .tscn scene file
                        ror scene-tree scenes/prototype/prototype_main.tscn
                        ror scene-tree scenes/game.tscn --depth 2
  validate-assets [-v] Validate assets against ADR-008 rules (alias: va)
                        ror validate-assets         — check all assets
                        ror validate-assets -v      — verbose output
  validate-sprites [opts]  Validate rendered unit sprite sets (alias: vs)
                        ror validate-sprites            — check all units
                        ror validate-sprites --unit archer  — check one unit
                        ror validate-sprites -v         — verbose output
  data-check [opts]   Validate JSON data files against schemas
                        ror data-check              — check all data files
                        ror data-check --verbose    — show per-file detail
  process-sprite <source.png> [opts]
                      Process a source building sprite to game-ready asset
                        ror process-sprite assets/sprites/buildings/lumber_camp_01.png
                        ror process-sprite source.png --canvas 256x192 --output out.png
                        ror process-sprite source.png --building barracks --dry-run
  blender-render [subject] [opts]
                      Render isometric sprites via Blender (headless)
                        ror blender-render --poc             — PoC house, all 8 directions
                        ror blender-render house --footprint 2 --directions s sw
                        ror blender-render villager --type unit --directions s n
  blender-archer        Render geometric archer (full pipeline: Blender → downscale → manifest)
                        Produces 192 frames (4 anims × 8 dirs × variable frame counts)
  asset-pipeline <subject> [opts]  (alias: pipeline)
                      Run full 3D-to-2D asset pipeline (render → manifest → pack → validate)
                        ror asset-pipeline archer --type unit
                        ror pipeline archer --skip-render   — reprocess existing renders
                        ror pipeline house --type building --footprint 2
  pack-sprites <subject> [opts]
                      Pack individual sprite PNGs into atlas spritesheets
                        ror pack-sprites villager            — pack villager sprites
                        ror pack-sprites archer --dry-run    — preview without writing
                        ror pack-sprites villager --max-width 2048
  sprite-sheet <variant> [animation] [direction] [--png] [--speed MS]
                      Generate animated GIFs (default) or static contact sheets
                        ror sprite-sheet villager_woman walk_c s  — animated GIF
                        ror sprite-sheet villager_woman walk_c    — GIF per direction
                        ror sprite-sheet villager_woman           — all animations
                        ror sprite-sheet villager_woman walk_c --png  — static sheet
                        ror sprite-sheet villager_woman walk_c --speed 150  — faster
  animate [animation] [direction]
                      Capture live animation filmstrips from the debug server
                        ror animate walk s              — filmstrip of walk-south
                        ror animate walk                — all 8 directions
                        ror animate                     — walk in all directions
                      Requires: game running with --debug-server
  split-sprites <input.png> [opts]
                      Split a spritesheet into individual tiles
                        ror split-sprites assets/raw/terrain/grass_quad.png --tile-size 128x64
                        ror split-sprites input.png --output-dir out/ --prefix name
  screenshot [opts]   Capture a screenshot from the running debug server
                        ror screenshot                          — save timestamped PNG
                        ror screenshot --name my_shot           — save as my_shot.png
                        ror screenshot --output /tmp/shot.png   — save to custom path
                        ror screenshot --annotate               — overlay debug annotations
  entities [options]  List all game entities from the debug server
                        ror entities                    — all entities (JSON)
                        ror entities --category unit    — only units
                        ror entities --type villager    — filter by type
                        ror entities --owner 0          — player 0 only
  units [--all]       Compact unit status table from the debug server
                        ror units                       — player units only
                        ror units --all                 — all entities
  wait-until <cond> [--timeout N] [--interval N]
                      Poll debug server until condition is met
                        ror wait-until wood>250             — wait for 250+ wood
                        ror wait-until food>=100            — wait for 100+ food
                        ror wait-until time>120             — wait until game time > 120s
                        ror wait-until idle>3               — wait for 3+ idle player units
                        ror wait-until gold>500 --timeout 120 --interval 2
  test-scenarios [opts]
                      Run all .scenario files as integration tests
                        ror test-scenarios                      — run all scenarios
                        ror test-scenarios --filter gather      — run matching scenarios
                        ror test-scenarios --civ polynesia      — use a specific civ
                        ror test-scenarios --no-screenshots     — skip failure screenshots
                      Launches Godot with --debug-server, runs each scenario file
                      in tests/scenarios/, resets the scene between runs, captures
                      failure screenshots, and reports pass/fail summary.
  scenario <script> | --file <path>
                      Execute a semicolon-separated sequence of debug commands
                        ror scenario 'select-all; gather 5 4; wait wood>250'
                        ror scenario --file tests/scenarios/gather_test.scenario
                      Commands: select-all, gather X Y, right-click X Y,
                        camera-to X Y, speed N, pause, unpause, screenshot [NAME] [--annotate],
                        wait CONDITION, sleep N, status, entities, stop,
                        spawn TYPE X Y [OWNER], teleport X Y,
                        place-building NAME X Y [OWNER] [--under-construction]
                      Assertions (fail scenario on mismatch):
                        assert CONDITION              — e.g. assert food>=100
                        assert-count [filters] OP N   — e.g. assert-count --owner 0 >= 5
                        assert-no-idle                — all player units must be busy
                        assert-building-at NAME X Y   — building exists at grid pos
                        assert-entity-hp [filters] OP N — HP check on matching entities
  stop [unit_ids...]  Stop all actions (combat, gather, movement) on selected units
                        ror stop                        — stop selected units
                        ror stop Unit1 Unit2            — stop specific units by name
  game-status         Query game state from the debug server (pretty-printed JSON)
  game-cmd <action> [key=value ...]
                      Send a command to the debug server
                        ror game-cmd select-all
                        ror game-cmd camera-to x=100 y=200
                        ror game-cmd speed rate=2
  help                Show this help message

${BOLD}ENVIRONMENT${RESET}
  GODOT_BIN           Path to Godot binary (auto-detected if unset)
  BLENDER_BIN         Path to Blender binary (auto-detected if unset)
EOF
}

# ==================== main ====================
case "${1:-help}" in
    test)     shift; cmd_test "$@" ;;
    lint)     shift; cmd_lint "$@" ;;
    scaffold) shift; cmd_scaffold "$@" ;;
    new-test)     shift; cmd_new_test "$@" ;;
    coverage)     shift; cmd_coverage "$@" ;;
    gen-sprites)        shift; cmd_gen_sprites "$@" ;;
    scene-tree)         shift; cmd_scene_tree "$@" ;;
    validate-assets|va) shift; cmd_validate_assets "$@" ;;
    validate-sprites|vs) shift; cmd_validate_sprites "$@" ;;
    process-sprite)     shift; cmd_process_sprite "$@" ;;
    blender-render)     shift; cmd_blender_render "$@" ;;
    blender-archer)     shift; cmd_blender_archer "$@" ;;
    sprite-sheet)       shift; cmd_sprite_sheet "$@" ;;
    pack-sprites)       shift; cmd_pack_sprites "$@" ;;
    asset-pipeline|pipeline) shift; cmd_asset_pipeline "$@" ;;
    animate)            shift; cmd_animate "$@" ;;
    data-check)         shift; cmd_data_check "$@" ;;
    split-sprites)      shift; cmd_split_sprites "$@" ;;
    screenshot)         shift; cmd_screenshot "$@" ;;
    entities)           shift; cmd_entities "$@" ;;
    units)              shift; cmd_units "$@" ;;
    wait-until)         shift; cmd_wait_until "$@" ;;
    scenario)           shift; cmd_scenario "$@" ;;
    test-scenarios)     shift; cmd_test_scenarios "$@" ;;
    game-status)        shift; cmd_game_status "$@" ;;
    combat-log)         shift; cmd_combat_log "$@" ;;
    economy)            shift; cmd_economy "$@" ;;
    pathfinding)        shift; cmd_pathfinding "$@" ;;
    perf)               shift; cmd_perf "$@" ;;
    fow)                shift; cmd_fow "$@" ;;
    stop)               shift; cmd_stop "$@" ;;
    reset)              shift; cmd_reset "$@" ;;
    game-cmd)           shift; cmd_game_cmd "$@" ;;
    help|--help|-h) cmd_help ;;
    *)
        err "Unknown command: $1"
        cmd_help
        exit 1
        ;;
esac
