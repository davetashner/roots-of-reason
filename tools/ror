#!/usr/bin/env bash
# Requires bash 4+ for associative arrays. Install via: brew install bash
# ror — Roots of Reason developer CLI
# Usage: ror <command> [options]
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# --- Colors ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
RESET='\033[0m'

# --- Helpers ---
info()  { printf "${CYAN}▸${RESET} %s\n" "$*"; }
ok()    { printf "${GREEN}✔${RESET} %s\n" "$*"; }
warn()  { printf "${YELLOW}⚠${RESET} %s\n" "$*"; }
err()   { printf "${RED}✖${RESET} %s\n" "$*" >&2; }

# --- Godot binary detection ---
find_godot() {
    if [[ -n "${GODOT_BIN:-}" ]] && [[ -x "$GODOT_BIN" ]]; then
        echo "$GODOT_BIN"
        return
    fi
    # Common locations on macOS
    local candidates=(
        "/Applications/Godot.app/Contents/MacOS/Godot"
        "/Applications/Godot_mono.app/Contents/MacOS/Godot"
        "$HOME/Applications/Godot.app/Contents/MacOS/Godot"
    )
    # Also check PATH
    if command -v godot &>/dev/null; then
        command -v godot
        return
    fi
    for bin in "${candidates[@]}"; do
        if [[ -x "$bin" ]]; then
            echo "$bin"
            return
        fi
    done
    return 1
}

# --- gdtoolkit venv management ---
VENV_DIR="$PROJECT_ROOT/.venv-gdtoolkit"

ensure_gdtoolkit() {
    if [[ -x "$VENV_DIR/bin/gdlint" ]] && [[ -x "$VENV_DIR/bin/gdformat" ]]; then
        return
    fi
    info "Setting up gdtoolkit virtualenv at $VENV_DIR ..."
    python3 -m venv "$VENV_DIR"
    "$VENV_DIR/bin/pip" install --quiet "gdtoolkit==4.*"
    ok "gdtoolkit installed"
}

# ==================== test ====================

# Map a changed .gd file to its test file path (relative to project root).
# scripts/foo/bar.gd  -> tests/foo/test_bar.gd
# tests/foo/test_x.gd -> tests/foo/test_x.gd (already a test)
# Returns empty string if no mapping exists.
_map_to_test_file() {
    local file="$1"
    if [[ "$file" == tests/* ]]; then
        # Already a test file — include it directly
        if [[ -f "$file" ]]; then
            echo "$file"
        fi
        return
    fi
    if [[ "$file" != scripts/* ]]; then
        return
    fi
    # scripts/foo/bar.gd -> tests/foo/test_bar.gd
    local rel="${file#scripts/}"
    local dir rel_dir base test_path
    dir="$(dirname "$rel")"
    base="$(basename "$rel")"
    if [[ "$dir" == "." ]]; then
        test_path="tests/test_${base}"
    else
        test_path="tests/${dir}/test_${base}"
    fi
    if [[ -f "$test_path" ]]; then
        echo "$test_path"
    fi
}

# Resolve --changed: find test files affected by local changes.
# Prints file paths to stdout (one per line). Info messages go to stderr.
_resolve_changed_tests() {
    local -a test_files=()
    local -a changed_files=()

    # Uncommitted changes (staged + unstaged)
    while IFS= read -r f; do
        [[ -n "$f" ]] && changed_files+=("$f")
    done < <(git diff --name-only HEAD -- '*.gd' 2>/dev/null)

    # Staged but not yet committed
    while IFS= read -r f; do
        [[ -n "$f" ]] && changed_files+=("$f")
    done < <(git diff --cached --name-only -- '*.gd' 2>/dev/null)

    # Changes since merge-base with main (for feature branches)
    local merge_base
    merge_base=$(git merge-base HEAD origin/main 2>/dev/null || echo "")
    if [[ -n "$merge_base" ]]; then
        while IFS= read -r f; do
            [[ -n "$f" ]] && changed_files+=("$f")
        done < <(git diff --name-only "$merge_base" HEAD -- '*.gd' 2>/dev/null)
    fi

    # Deduplicate
    local -A seen=()
    for f in "${changed_files[@]}"; do
        local test_file
        test_file=$(_map_to_test_file "$f")
        if [[ -n "$test_file" ]] && [[ -z "${seen[$test_file]:-}" ]]; then
            seen["$test_file"]=1
            test_files+=("$test_file")
        fi
    done

    if [[ ${#test_files[@]} -eq 0 ]]; then
        warn "No changed test files found — nothing to run" >&2
        return 1
    fi

    info "Running ${#test_files[@]} changed test file(s):" >&2
    for tf in "${test_files[@]}"; do
        printf "  %s\n" "$tf" >&2
    done

    # Output file paths to stdout only
    printf '%s\n' "${test_files[@]}"
}

# Run a single Godot test process with the given --add arguments.
# Usage: _run_godot_tests <godot> <live> <test_args...>
_run_godot_tests() {
    local godot="$1"
    local live="$2"
    shift 2
    local test_args=("$@")

    local godot_flags=("-s")
    if $live; then
        godot_flags+=("-d" "--verbose")
        printf "${BOLD}Running GdUnit4 tests (live) …${RESET}\n"
        info "Godot window will display test scenes — output streams in real time"
        if command -v stdbuf &>/dev/null; then
            stdbuf -oL "$godot" --path . "${godot_flags[@]}" res://addons/gdUnit4/bin/GdUnitCmdTool.gd "${test_args[@]}"
        else
            "$godot" --path . "${godot_flags[@]}" res://addons/gdUnit4/bin/GdUnitCmdTool.gd "${test_args[@]}"
        fi
    else
        godot_flags+=("--headless")
        "$godot" --path . "${godot_flags[@]}" res://addons/gdUnit4/bin/GdUnitCmdTool.gd --ignoreHeadlessMode "${test_args[@]}"
    fi
    return $?
}

# Run tests sharded across N parallel Godot processes.
_run_sharded_tests() {
    local godot="$1"
    local jobs="$2"
    shift 2
    local test_args=("$@")

    # Discover all test files from the provided paths
    local -a all_test_files=()
    local i=0
    while [[ $i -lt ${#test_args[@]} ]]; do
        if [[ "${test_args[$i]}" == "--add" ]]; then
            i=$((i + 1))
            local path="${test_args[$i]}"
            # Convert res:// to filesystem path
            path="${path#res://}"
            if [[ -d "$path" ]]; then
                while IFS= read -r f; do
                    all_test_files+=("$f")
                done < <(find "$path" -name "test_*.gd" -type f | sort)
            elif [[ -f "$path" ]]; then
                all_test_files+=("$path")
            fi
        fi
        i=$((i + 1))
    done

    local total=${#all_test_files[@]}
    if [[ $total -eq 0 ]]; then
        warn "No test files found"
        return 0
    fi

    # Cap jobs at file count
    if [[ $jobs -gt $total ]]; then
        jobs=$total
    fi

    info "Sharding $total test files across $jobs parallel processes"

    # Distribute files round-robin into shard arrays
    local -a pids=()
    local -a shard_logs=()
    local shard_size=$(( (total + jobs - 1) / jobs ))

    for (( j=0; j<jobs; j++ )); do
        local -a shard_args=()
        for (( k=j; k<total; k+=jobs )); do
            shard_args+=("--add" "res://${all_test_files[$k]}")
        done

        if [[ ${#shard_args[@]} -eq 0 ]]; then
            continue
        fi

        local log_file
        log_file=$(mktemp "${TMPDIR:-/tmp}/ror-shard-${j}-XXXXXX.log")
        shard_logs+=("$log_file")

        info "Shard $((j+1))/$jobs: ${#shard_args[@]} args ($(( ${#shard_args[@]} / 2 )) files)"

        (
            "$godot" --path . -s --headless \
                res://addons/gdUnit4/bin/GdUnitCmdTool.gd \
                --ignoreHeadlessMode \
                -rd "reports/shard_${j}" \
                "${shard_args[@]}" \
                > "$log_file" 2>&1
        ) &
        pids+=($!)
    done

    # Wait for all shards and track exit codes.
    # GdUnit4 exit codes: 0 = pass, 100 = failure, 101 = orphan warning (still pass).
    local worst_exit=0
    local shard_idx=0
    for pid in "${pids[@]}"; do
        local shard_exit=0
        wait "$pid" || shard_exit=$?
        # Treat 101 (orphan warning) as success — same as single-process runner
        local effective_exit=$shard_exit
        if [[ $effective_exit -eq 101 ]]; then
            effective_exit=0
        fi
        if [[ $effective_exit -gt $worst_exit ]]; then
            worst_exit=$effective_exit
        fi
        # Print shard output
        printf "\n${BOLD}── Shard %d/%d (exit %d) ──${RESET}\n" "$((shard_idx+1))" "${#pids[@]}" "$shard_exit"
        # Show only the summary line from each shard
        grep -E "^(Statistics:|Overall Summary:)" "${shard_logs[$shard_idx]}" 2>/dev/null || tail -5 "${shard_logs[$shard_idx]}"
        shard_idx=$((shard_idx + 1))
    done

    # On failure, keep logs for debugging; on success, clean up
    if [[ $worst_exit -gt 0 ]]; then
        for (( si=0; si<${#shard_logs[@]}; si++ )); do
            info "Shard $((si+1)) log: ${shard_logs[$si]}"
        done
    else
        for log in "${shard_logs[@]}"; do
            rm -f "$log"
        done
    fi

    return $worst_exit
}

cmd_test() {
    local godot
    if ! godot=$(find_godot); then
        err "Godot binary not found."
        echo "  Set GODOT_BIN or install Godot to a standard location."
        exit 1
    fi
    info "Using Godot: $godot"

    local live=false
    local changed=false
    local jobs=0
    local test_args=()
    local raw_args=()

    # Parse flags
    for arg in "$@"; do
        case "$arg" in
            --live)    live=true ;;
            --changed) changed=true ;;
            --jobs=*)  jobs="${arg#--jobs=}" ;;
            --jobs)    err "--jobs requires a value (e.g., --jobs=4)"; exit 1 ;;
            *)         raw_args+=("$arg") ;;
        esac
    done

    cd "$PROJECT_ROOT"

    # Handle --changed: resolve affected test files
    if $changed; then
        local -a changed_files=()
        while IFS= read -r f; do
            [[ -n "$f" ]] && changed_files+=("$f")
        done < <(_resolve_changed_tests)

        if [[ ${#changed_files[@]} -eq 0 ]]; then
            return 0
        fi

        for tf in "${changed_files[@]}"; do
            raw_args+=("$tf")
        done
    fi

    # Build GdUnit4 --add arguments
    if [[ ${#raw_args[@]} -gt 0 ]]; then
        for arg in "${raw_args[@]}"; do
            if [[ "$arg" == tests/* ]] || [[ "$arg" == ./tests/* ]]; then
                arg="${arg#./}"
                test_args+=("--add" "res://$arg")
            elif [[ "$arg" == res://* ]]; then
                test_args+=("--add" "$arg")
            else
                test_args+=("$arg")
            fi
        done
    else
        test_args=("--add" "res://tests")
    fi

    # Ensure .godot cache is fresh (needed for class resolution)
    info "Importing project resources ..."
    "$godot" --headless --path . --import >/dev/null 2>&1 || true

    local exit_code=0

    if [[ $jobs -gt 1 ]]; then
        printf "${BOLD}Running GdUnit4 tests (${jobs} parallel shards) …${RESET}\n"
        _run_sharded_tests "$godot" "$jobs" "${test_args[@]}" || exit_code=$?
    else
        printf "${BOLD}Running GdUnit4 tests …${RESET}\n"
        _run_godot_tests "$godot" "$live" "${test_args[@]}" || exit_code=$?
    fi

    # Copy logs silently (skip for sharded runs — each shard writes its own)
    if [[ $jobs -le 1 ]]; then
        "$godot" --headless --path . --quiet -s res://addons/gdUnit4/bin/GdUnitCopyLog.gd "${test_args[@]}" >/dev/null 2>&1 || true
    fi

    echo ""
    if [[ $exit_code -eq 0 ]]; then
        ok "All tests passed"
    else
        err "Tests failed (exit code $exit_code)"
    fi
    return $exit_code
}

# ==================== lint ====================
cmd_lint() {
    ensure_gdtoolkit
    local gdlint="$VENV_DIR/bin/gdlint"
    local gdformat="$VENV_DIR/bin/gdformat"
    local fix=false
    local targets=("scripts/" "tests/")

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --fix) fix=true; shift ;;
            *)     targets=("$@"); break ;;
        esac
    done

    cd "$PROJECT_ROOT"
    local exit_code=0

    if $fix; then
        info "Auto-formatting with gdformat ..."
        "$gdformat" "${targets[@]}" || true
        ok "Formatting complete"
    fi

    printf "${BOLD}Running gdlint …${RESET}\n"
    if "$gdlint" "${targets[@]}"; then
        ok "Lint passed"
    else
        err "Lint issues found"
        exit_code=1
    fi

    if ! $fix; then
        printf "${BOLD}Checking format …${RESET}\n"
        if "$gdformat" --check "${targets[@]}"; then
            ok "Format check passed"
        else
            warn "Format issues found — run 'ror lint --fix' to auto-format"
            exit_code=1
        fi
    fi

    return $exit_code
}

# ==================== coverage ====================
cmd_coverage() {
    local threshold=90
    local json=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --threshold) threshold="$2"; shift 2 ;;
            --json)      json=true; shift ;;
            *)           err "Unknown coverage option: $1"; exit 1 ;;
        esac
    done

    cd "$PROJECT_ROOT"

    # Collect all .gd files under scripts/
    local -a scripts=()
    while IFS= read -r -d '' f; do
        scripts+=("$f")
    done < <(find scripts/ -name '*.gd' -print0 2>/dev/null | sort -z)

    local total=${#scripts[@]}
    if [[ $total -eq 0 ]]; then
        if $json; then
            printf '{"total":0,"covered":0,"uncovered":0,"percentage":100,"threshold":%d,"pass":true,"uncovered_files":[]}\n' "$threshold"
        else
            ok "No scripts found — nothing to cover"
        fi
        return 0
    fi

    local covered=0
    local -a uncovered=()
    local -a covered_files=()

    for script in "${scripts[@]}"; do
        # scripts/foo/bar.gd → tests/foo/test_bar.gd
        local dir rel_dir base test_path
        dir="$(dirname "$script")"
        rel_dir="${dir#scripts}"
        rel_dir="${rel_dir#/}"
        base="$(basename "$script")"
        if [[ -n "$rel_dir" ]]; then
            test_path="tests/${rel_dir}/test_${base}"
        else
            test_path="tests/test_${base}"
        fi

        if [[ -f "$test_path" ]]; then
            covered=$((covered + 1))
            covered_files+=("$script")
        else
            uncovered+=("$script")
        fi
    done

    local pct=$(( (covered * 100) / total ))
    local pass=true
    if [[ $pct -lt $threshold ]]; then
        pass=false
    fi

    if $json; then
        # Build JSON output
        local uncov_json="["
        local first=true
        for f in "${uncovered[@]}"; do
            if $first; then first=false; else uncov_json+=","; fi
            uncov_json+="\"$f\""
        done
        uncov_json+="]"
        printf '{"total":%d,"covered":%d,"uncovered":%d,"percentage":%d,"threshold":%d,"pass":%s,"uncovered_files":%s}\n' \
            "$total" "$covered" "$((total - covered))" "$pct" "$threshold" "$pass" "$uncov_json"
    else
        printf "${BOLD}Test-file coverage report${RESET}\n"
        echo ""
        if [[ ${#uncovered[@]} -gt 0 ]]; then
            printf "${YELLOW}Uncovered scripts (no matching test file):${RESET}\n"
            for f in "${uncovered[@]}"; do
                printf "  ${RED}✗${RESET} %s\n" "$f"
            done
            echo ""
        fi
        if [[ ${#covered_files[@]} -gt 0 ]]; then
            printf "${GREEN}Covered scripts:${RESET}\n"
            for f in "${covered_files[@]}"; do
                printf "  ${GREEN}✔${RESET} %s\n" "$f"
            done
            echo ""
        fi
        printf "Coverage: ${BOLD}%d/%d (%d%%)${RESET}  Threshold: %d%%\n" "$covered" "$total" "$pct" "$threshold"
        echo ""
        if $pass; then
            ok "Coverage gate passed"
        else
            err "Coverage gate failed — ${pct}% < ${threshold}% threshold"
            return 1
        fi
    fi

    if ! $pass; then
        return 1
    fi
    return 0
}

# ==================== scaffold ====================
cmd_scaffold() {
    if [[ $# -lt 1 ]]; then
        err "Usage: ror scaffold <path/name> [--type Node2D]"
        echo "  Example: ror scaffold map/pathfinder"
        echo "  Example: ror scaffold ui/minimap --type Control"
        exit 1
    fi

    local feature_path="$1"
    shift
    local base_type="Node2D"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --type) base_type="$2"; shift 2 ;;
            *)      err "Unknown scaffold option: $1"; exit 1 ;;
        esac
    done

    # Derive names from path
    local dir_part name
    dir_part="$(dirname "$feature_path")"
    name="$(basename "$feature_path")"

    # PascalCase from snake_case
    local pascal_name=""
    IFS='_' read -ra parts <<< "$name"
    for part in "${parts[@]}"; do
        pascal_name+="$(tr '[:lower:]' '[:upper:]' <<< "${part:0:1}")${part:1}"
    done

    # Build file paths
    local scene_dir script_dir test_dir
    if [[ "$dir_part" == "." ]]; then
        scene_dir="$PROJECT_ROOT/scenes"
        script_dir="$PROJECT_ROOT/scripts"
        test_dir="$PROJECT_ROOT/tests"
    else
        scene_dir="$PROJECT_ROOT/scenes/$dir_part"
        script_dir="$PROJECT_ROOT/scripts/$dir_part"
        test_dir="$PROJECT_ROOT/tests/$dir_part"
    fi

    local scene_file="$scene_dir/${name}.tscn"
    local script_file="$script_dir/${name}.gd"
    local test_file="$test_dir/test_${name}.gd"

    # Refuse to overwrite
    local conflict=false
    for f in "$scene_file" "$script_file" "$test_file"; do
        if [[ -f "$f" ]]; then
            err "File already exists: $f"
            conflict=true
        fi
    done
    if $conflict; then
        exit 1
    fi

    # Build res:// path for script reference
    local res_script_path
    if [[ "$dir_part" == "." ]]; then
        res_script_path="res://scripts/${name}.gd"
    else
        res_script_path="res://scripts/${dir_part}/${name}.gd"
    fi

    # Create directories
    mkdir -p "$scene_dir" "$script_dir" "$test_dir"

    # Write scene file
    cat > "$scene_file" <<TSCN
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="${res_script_path}" id="1"]

[node name="${pascal_name}" type="${base_type}"]
script = ExtResource("1")
TSCN

    # Write script file
    cat > "$script_file" <<GDSCRIPT
extends ${base_type}
## TODO: describe ${pascal_name}.
GDSCRIPT

    # Write test file
    cat > "$test_file" <<GDTEST
extends GdUnitTestSuite
## Tests for ${pascal_name}.


func test_placeholder() -> void:
	assert_bool(true).is_true()
GDTEST

    ok "Created: $scene_file"
    ok "Created: $script_file"
    ok "Created: $test_file"
}

# ==================== new-test ====================
cmd_new_test() {
    if [[ $# -lt 1 ]]; then
        err "Usage: ror new-test <script.gd>"
        echo "  Example: ror new-test scripts/autoloads/resource_manager.gd"
        exit 1
    fi

    local source_path="$1"

    # Resolve relative to project root
    cd "$PROJECT_ROOT"

    # Validate source file exists
    if [[ ! -f "$source_path" ]]; then
        err "Source file not found: $source_path"
        exit 1
    fi

    # Validate it lives under scripts/
    if [[ "$source_path" != scripts/* ]]; then
        err "Source file must be under scripts/ (got: $source_path)"
        exit 1
    fi

    # Derive test path: scripts/foo/bar.gd -> tests/foo/test_bar.gd
    local rel_path="${source_path#scripts/}"
    local dir_part base test_dir test_path
    dir_part="$(dirname "$rel_path")"
    base="$(basename "$rel_path")"

    if [[ "$dir_part" == "." ]]; then
        test_dir="tests"
    else
        test_dir="tests/$dir_part"
    fi
    test_path="${test_dir}/test_${base}"

    # Refuse to overwrite existing test files
    if [[ -f "$test_path" ]]; then
        err "Test file already exists: $test_path"
        exit 1
    fi

    # Extract class_name (if declared) or derive PascalCase from filename
    local class_name=""
    class_name=$(grep -m1 '^class_name ' "$source_path" | sed 's/^class_name //' | tr -d '[:space:]' || true)
    if [[ -z "$class_name" ]]; then
        # Convert snake_case filename to PascalCase
        local name_no_ext="${base%.gd}"
        class_name=""
        IFS='_' read -ra parts <<< "$name_no_ext"
        for part in "${parts[@]}"; do
            class_name+="$(tr '[:lower:]' '[:upper:]' <<< "${part:0:1}")${part:1}"
        done
    fi

    # Extract public function names (lines starting with "func " where the
    # function name does NOT begin with "_")
    local -a funcs=()
    while IFS= read -r line; do
        # Extract function name from "func name(..." pattern
        local fname
        fname=$(echo "$line" | sed -n 's/^func \([a-zA-Z][a-zA-Z0-9_]*\).*/\1/p')
        if [[ -n "$fname" ]]; then
            funcs+=("$fname")
        fi
    done < <(grep '^func [^_]' "$source_path")

    # Create intermediate directories
    mkdir -p "$test_dir"

    # Write the test file
    {
        printf 'extends GdUnitTestSuite\n'
        printf '## Tests for %s.\n' "$class_name"

        if [[ ${#funcs[@]} -eq 0 ]]; then
            printf '\n\n'
            printf 'func test_placeholder() -> void:\n'
            printf '\tassert_bool(true).is_true()\n'
        else
            for fname in "${funcs[@]}"; do
                printf '\n\n'
                printf 'func test_%s() -> void:\n' "$fname"
                printf '\tassert_bool(true).is_true()\n'
            done
        fi
    } > "$test_path"

    ok "Created: $test_path"
    info "Found ${#funcs[@]} public function(s) in $source_path"
    if [[ ${#funcs[@]} -gt 0 ]]; then
        for fname in "${funcs[@]}"; do
            printf "  test_%s\n" "$fname"
        done
    fi
}

# ==================== gen-sprites ====================

# Registry of sprite categories → generator scripts.
# Add new entries here as generators are created.
ALL_SPRITE_CATEGORIES="tiles"

generator_for() {
    case "$1" in
        tiles) echo "tools/generate_prototype_tiles.py" ;;
        *)     return 1 ;;
    esac
}

cmd_gen_sprites() {
    cd "$PROJECT_ROOT"

    # Determine which categories to run
    local -a categories=()
    if [[ $# -eq 0 ]]; then
        # No argument — run all generators
        for cat in $ALL_SPRITE_CATEGORIES; do
            categories+=("$cat")
        done
    else
        for cat in "$@"; do
            if ! generator_for "$cat" >/dev/null 2>&1; then
                err "Unknown sprite category: $cat"
                echo "  Available categories: $ALL_SPRITE_CATEGORIES"
                exit 1
            fi
            categories+=("$cat")
        done
    fi

    local total=${#categories[@]}
    local passed=0
    local failed=0
    local overall_start=$SECONDS

    local label="categories"
    [[ $total -eq 1 ]] && label="category"
    printf "${BOLD}Generating sprites (%d %s) …${RESET}\n" "$total" "$label"

    for cat in "${categories[@]}"; do
        local script
        script="$(generator_for "$cat")"
        local start=$SECONDS

        info "[$cat] Running $script ..."
        if python3 "$script"; then
            local elapsed=$(( SECONDS - start ))
            ok "[$cat] Done (${elapsed}s)"
            passed=$((passed + 1))
        else
            local elapsed=$(( SECONDS - start ))
            err "[$cat] Failed (${elapsed}s)"
            failed=$((failed + 1))
        fi
    done

    local overall_elapsed=$(( SECONDS - overall_start ))
    echo ""
    printf "${BOLD}Sprite generation complete${RESET} — %d passed, %d failed (%ds total)\n" \
        "$passed" "$failed" "$overall_elapsed"

    if [[ $failed -gt 0 ]]; then
        err "Some generators failed"
        return 1
    fi
    ok "All sprites generated"
    return 0
}

# ==================== split-sprites ====================
cmd_split_sprites() {
    cd "$PROJECT_ROOT"
    python3 "$SCRIPT_DIR/split_spritesheet.py" "$@"
}

# ==================== scene-tree ====================
cmd_scene_tree() {
    cd "$PROJECT_ROOT"
    python3 "$SCRIPT_DIR/scene_tree.py" "$@"
}

# ==================== process-sprite ====================
cmd_process_sprite() {
    cd "$PROJECT_ROOT"
    python3 "$SCRIPT_DIR/process_sprite.py" "$@"
}

# ==================== validate-assets ====================
cmd_validate_assets() {
    cd "$PROJECT_ROOT"
    info "Validating assets against ADR-008 rules ..."
    python3 "$SCRIPT_DIR/validate_assets.py" "$@"
    local exit_code=$?
    if [[ $exit_code -eq 0 ]]; then
        ok "Asset validation passed"
    else
        err "Asset validation failed"
    fi
    return $exit_code
}

# ==================== data-check ====================
cmd_data_check() {
    cd "$PROJECT_ROOT"
    printf "${BOLD}Validating data files against schemas …${RESET}\n"
    python3 "$SCRIPT_DIR/data_check.py" "$@"
}

# ==================== screenshot ====================
cmd_screenshot() {
    local output=""
    local name=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --output) output="$2"; shift 2 ;;
            --name)   name="$2"; shift 2 ;;
            *)        err "Unknown screenshot option: $1"; exit 1 ;;
        esac
    done

    if [[ -z "$output" ]]; then
        if [[ -z "$name" ]]; then
            name="$(date +%Y%m%d_%H%M%S)"
        fi
        mkdir -p "$PROJECT_ROOT/tests/screenshots"
        output="$PROJECT_ROOT/tests/screenshots/${name}.png"
    fi

    curl -s "http://127.0.0.1:9222/screenshot" -o "$output"
    echo "$output"
}

# ==================== game-status ====================
cmd_game_status() {
    curl -s "http://127.0.0.1:9222/status" | python3 -m json.tool
}

# ==================== game-cmd ====================
cmd_game_cmd() {
    if [[ $# -lt 1 ]]; then
        err "Usage: ror game-cmd <action> [key=value ...]"
        exit 1
    fi

    local action="$1"
    shift

    # Build JSON: start with action field
    local json="{\"action\": \"${action}\""
    for arg in "$@"; do
        local key="${arg%%=*}"
        local val="${arg#*=}"
        # Try to detect numeric values
        if [[ "$val" =~ ^-?[0-9]+\.?[0-9]*$ ]]; then
            json+=", \"${key}\": ${val}"
        else
            json+=", \"${key}\": \"${val}\""
        fi
    done
    json+="}"

    curl -s -X POST -H 'Content-Type: application/json' -d "$json" "http://127.0.0.1:9222/command"
    echo ""
}

# ==================== entities ====================
cmd_entities() {
    local query=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --category) query="${query:+$query&}category=$2"; shift 2 ;;
            --type)     query="${query:+$query&}type=$2"; shift 2 ;;
            --owner)    query="${query:+$query&}owner=$2"; shift 2 ;;
            *)          err "Unknown entities option: $1"; exit 1 ;;
        esac
    done

    local url="http://127.0.0.1:9222/entities"
    if [[ -n "$query" ]]; then
        url="${url}?${query}"
    fi

    curl -s "$url" | python3 -m json.tool
}

# ==================== help ====================
cmd_help() {
    cat <<EOF
${BOLD}ror${RESET} — Roots of Reason developer CLI

${BOLD}USAGE${RESET}
  ror <command> [options]

${BOLD}COMMANDS${RESET}
  test [path...] [--live] [--changed] [--jobs=N]
                      Run GdUnit4 tests
                        ror test                    — run all tests
                        ror test tests/autoloads/   — run a subset
                        ror test --live             — stream output in real time
                        ror test tests/ui/ --live   — live subset run
                        ror test --changed          — only test changed files
                        ror test --jobs=4           — run tests in 4 parallel shards
  lint [--fix] [path] Run gdlint + gdformat check
                        ror lint                    — check scripts/ tests/
                        ror lint --fix              — auto-format then lint
  scaffold <path/name> [--type Node2D]
                      Create scene + script + test boilerplate
                        ror scaffold map/pathfinder
                        ror scaffold ui/minimap --type Control
  new-test <script.gd> Generate a GdUnit4 test file for a source script
                        ror new-test scripts/autoloads/resource_manager.gd
  coverage [options]  Test-file coverage gate
                        ror coverage                — check at 90% threshold
                        ror coverage --threshold 90 — custom threshold
                        ror coverage --json         — machine-readable output
  gen-sprites [cat..] Generate placeholder sprite assets
                        ror gen-sprites             — generate all categories
                        ror gen-sprites tiles       — generate only tiles
  scene-tree <file.tscn> [--depth N]
                      Print the node tree of a .tscn scene file
                        ror scene-tree scenes/prototype/prototype_main.tscn
                        ror scene-tree scenes/game.tscn --depth 2
  validate-assets [-v] Validate assets against ADR-008 rules (alias: va)
                        ror validate-assets         — check all assets
                        ror validate-assets -v      — verbose output
  data-check [opts]   Validate JSON data files against schemas
                        ror data-check              — check all data files
                        ror data-check --verbose    — show per-file detail
  process-sprite <source.png> [opts]
                      Process a source building sprite to game-ready asset
                        ror process-sprite assets/sprites/buildings/lumber_camp_01.png
                        ror process-sprite source.png --canvas 256x192 --output out.png
                        ror process-sprite source.png --building barracks --dry-run
  split-sprites <input.png> [opts]
                      Split a spritesheet into individual tiles
                        ror split-sprites assets/raw/terrain/grass_quad.png --tile-size 128x64
                        ror split-sprites input.png --output-dir out/ --prefix name
  screenshot [opts]   Capture a screenshot from the running debug server
                        ror screenshot                          — save timestamped PNG
                        ror screenshot --name my_shot           — save as my_shot.png
                        ror screenshot --output /tmp/shot.png   — save to custom path
  entities [options]  List all game entities from the debug server
                        ror entities                    — all entities (JSON)
                        ror entities --category unit    — only units
                        ror entities --type villager    — filter by type
                        ror entities --owner 0          — player 0 only
  game-status         Query game state from the debug server (pretty-printed JSON)
  game-cmd <action> [key=value ...]
                      Send a command to the debug server
                        ror game-cmd select-all
                        ror game-cmd camera-to x=100 y=200
                        ror game-cmd speed rate=2
  help                Show this help message

${BOLD}ENVIRONMENT${RESET}
  GODOT_BIN           Path to Godot binary (auto-detected if unset)
EOF
}

# ==================== main ====================
case "${1:-help}" in
    test)     shift; cmd_test "$@" ;;
    lint)     shift; cmd_lint "$@" ;;
    scaffold) shift; cmd_scaffold "$@" ;;
    new-test)     shift; cmd_new_test "$@" ;;
    coverage)     shift; cmd_coverage "$@" ;;
    gen-sprites)        shift; cmd_gen_sprites "$@" ;;
    scene-tree)         shift; cmd_scene_tree "$@" ;;
    validate-assets|va) shift; cmd_validate_assets "$@" ;;
    process-sprite)     shift; cmd_process_sprite "$@" ;;
    data-check)         shift; cmd_data_check "$@" ;;
    split-sprites)      shift; cmd_split_sprites "$@" ;;
    screenshot)         shift; cmd_screenshot "$@" ;;
    entities)           shift; cmd_entities "$@" ;;
    game-status)        shift; cmd_game_status "$@" ;;
    game-cmd)           shift; cmd_game_cmd "$@" ;;
    help|--help|-h) cmd_help ;;
    *)
        err "Unknown command: $1"
        cmd_help
        exit 1
        ;;
esac
