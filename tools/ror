#!/usr/bin/env bash
# ror — Roots of Reason developer CLI
# Usage: ror <command> [options]
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# --- Colors ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
RESET='\033[0m'

# --- Helpers ---
info()  { printf "${CYAN}▸${RESET} %s\n" "$*"; }
ok()    { printf "${GREEN}✔${RESET} %s\n" "$*"; }
warn()  { printf "${YELLOW}⚠${RESET} %s\n" "$*"; }
err()   { printf "${RED}✖${RESET} %s\n" "$*" >&2; }

# --- Godot binary detection ---
find_godot() {
    if [[ -n "${GODOT_BIN:-}" ]] && [[ -x "$GODOT_BIN" ]]; then
        echo "$GODOT_BIN"
        return
    fi
    # Common locations on macOS
    local candidates=(
        "/Applications/Godot.app/Contents/MacOS/Godot"
        "/Applications/Godot_mono.app/Contents/MacOS/Godot"
        "$HOME/Applications/Godot.app/Contents/MacOS/Godot"
    )
    # Also check PATH
    if command -v godot &>/dev/null; then
        command -v godot
        return
    fi
    for bin in "${candidates[@]}"; do
        if [[ -x "$bin" ]]; then
            echo "$bin"
            return
        fi
    done
    return 1
}

# --- gdtoolkit venv management ---
VENV_DIR="$PROJECT_ROOT/.venv-gdtoolkit"

ensure_gdtoolkit() {
    if [[ -x "$VENV_DIR/bin/gdlint" ]] && [[ -x "$VENV_DIR/bin/gdformat" ]]; then
        return
    fi
    info "Setting up gdtoolkit virtualenv at $VENV_DIR ..."
    python3 -m venv "$VENV_DIR"
    "$VENV_DIR/bin/pip" install --quiet "gdtoolkit==4.*"
    ok "gdtoolkit installed"
}

# ==================== test ====================
cmd_test() {
    local godot
    if ! godot=$(find_godot); then
        err "Godot binary not found."
        echo "  Set GODOT_BIN or install Godot to a standard location."
        exit 1
    fi
    info "Using Godot: $godot"

    local test_args=()
    if [[ $# -gt 0 ]]; then
        # Convert filesystem paths to res:// paths for GdUnit4
        for arg in "$@"; do
            if [[ "$arg" == tests/* ]] || [[ "$arg" == ./tests/* ]]; then
                arg="${arg#./}"
                test_args+=("--add" "res://$arg")
            elif [[ "$arg" == res://* ]]; then
                test_args+=("--add" "$arg")
            else
                test_args+=("$arg")
            fi
        done
    else
        test_args=("--add" "res://tests")
    fi

    cd "$PROJECT_ROOT"

    # Ensure .godot cache is fresh (needed for class resolution)
    info "Importing project resources ..."
    "$godot" --headless --path . --import >/dev/null 2>&1 || true

    printf "${BOLD}Running GdUnit4 tests …${RESET}\n"
    "$godot" --path . -s -d res://addons/gdUnit4/bin/GdUnitCmdTool.gd "${test_args[@]}"
    local exit_code=$?

    # Copy logs silently
    "$godot" --headless --path . --quiet -s res://addons/gdUnit4/bin/GdUnitCopyLog.gd "${test_args[@]}" >/dev/null 2>&1 || true

    echo ""
    if [[ $exit_code -eq 0 ]]; then
        ok "All tests passed"
    else
        err "Tests failed (exit code $exit_code)"
    fi
    return $exit_code
}

# ==================== lint ====================
cmd_lint() {
    ensure_gdtoolkit
    local gdlint="$VENV_DIR/bin/gdlint"
    local gdformat="$VENV_DIR/bin/gdformat"
    local fix=false
    local targets=("scripts/" "tests/")

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --fix) fix=true; shift ;;
            *)     targets=("$@"); break ;;
        esac
    done

    cd "$PROJECT_ROOT"
    local exit_code=0

    if $fix; then
        info "Auto-formatting with gdformat ..."
        "$gdformat" "${targets[@]}" || true
        ok "Formatting complete"
    fi

    printf "${BOLD}Running gdlint …${RESET}\n"
    if "$gdlint" "${targets[@]}"; then
        ok "Lint passed"
    else
        err "Lint issues found"
        exit_code=1
    fi

    if ! $fix; then
        printf "${BOLD}Checking format …${RESET}\n"
        if "$gdformat" --check "${targets[@]}"; then
            ok "Format check passed"
        else
            warn "Format issues found — run 'ror lint --fix' to auto-format"
            exit_code=1
        fi
    fi

    return $exit_code
}

# ==================== coverage ====================
cmd_coverage() {
    local threshold=90
    local json=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --threshold) threshold="$2"; shift 2 ;;
            --json)      json=true; shift ;;
            *)           err "Unknown coverage option: $1"; exit 1 ;;
        esac
    done

    cd "$PROJECT_ROOT"

    # Collect all .gd files under scripts/
    local -a scripts=()
    while IFS= read -r -d '' f; do
        scripts+=("$f")
    done < <(find scripts/ -name '*.gd' -print0 2>/dev/null | sort -z)

    local total=${#scripts[@]}
    if [[ $total -eq 0 ]]; then
        if $json; then
            printf '{"total":0,"covered":0,"uncovered":0,"percentage":100,"threshold":%d,"pass":true,"uncovered_files":[]}\n' "$threshold"
        else
            ok "No scripts found — nothing to cover"
        fi
        return 0
    fi

    local covered=0
    local -a uncovered=()
    local -a covered_files=()

    for script in "${scripts[@]}"; do
        # scripts/foo/bar.gd → tests/foo/test_bar.gd
        local dir rel_dir base test_path
        dir="$(dirname "$script")"
        rel_dir="${dir#scripts}"
        rel_dir="${rel_dir#/}"
        base="$(basename "$script")"
        if [[ -n "$rel_dir" ]]; then
            test_path="tests/${rel_dir}/test_${base}"
        else
            test_path="tests/test_${base}"
        fi

        if [[ -f "$test_path" ]]; then
            covered=$((covered + 1))
            covered_files+=("$script")
        else
            uncovered+=("$script")
        fi
    done

    local pct=$(( (covered * 100) / total ))
    local pass=true
    if [[ $pct -lt $threshold ]]; then
        pass=false
    fi

    if $json; then
        # Build JSON output
        local uncov_json="["
        local first=true
        for f in "${uncovered[@]}"; do
            if $first; then first=false; else uncov_json+=","; fi
            uncov_json+="\"$f\""
        done
        uncov_json+="]"
        printf '{"total":%d,"covered":%d,"uncovered":%d,"percentage":%d,"threshold":%d,"pass":%s,"uncovered_files":%s}\n' \
            "$total" "$covered" "$((total - covered))" "$pct" "$threshold" "$pass" "$uncov_json"
    else
        printf "${BOLD}Test-file coverage report${RESET}\n"
        echo ""
        if [[ ${#uncovered[@]} -gt 0 ]]; then
            printf "${YELLOW}Uncovered scripts (no matching test file):${RESET}\n"
            for f in "${uncovered[@]}"; do
                printf "  ${RED}✗${RESET} %s\n" "$f"
            done
            echo ""
        fi
        if [[ ${#covered_files[@]} -gt 0 ]]; then
            printf "${GREEN}Covered scripts:${RESET}\n"
            for f in "${covered_files[@]}"; do
                printf "  ${GREEN}✔${RESET} %s\n" "$f"
            done
            echo ""
        fi
        printf "Coverage: ${BOLD}%d/%d (%d%%)${RESET}  Threshold: %d%%\n" "$covered" "$total" "$pct" "$threshold"
        echo ""
        if $pass; then
            ok "Coverage gate passed"
        else
            err "Coverage gate failed — ${pct}% < ${threshold}% threshold"
            return 1
        fi
    fi

    if ! $pass; then
        return 1
    fi
    return 0
}

# ==================== scaffold ====================
cmd_scaffold() {
    if [[ $# -lt 1 ]]; then
        err "Usage: ror scaffold <path/name> [--type Node2D]"
        echo "  Example: ror scaffold map/pathfinder"
        echo "  Example: ror scaffold ui/minimap --type Control"
        exit 1
    fi

    local feature_path="$1"
    shift
    local base_type="Node2D"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --type) base_type="$2"; shift 2 ;;
            *)      err "Unknown scaffold option: $1"; exit 1 ;;
        esac
    done

    # Derive names from path
    local dir_part name
    dir_part="$(dirname "$feature_path")"
    name="$(basename "$feature_path")"

    # PascalCase from snake_case
    local pascal_name=""
    IFS='_' read -ra parts <<< "$name"
    for part in "${parts[@]}"; do
        pascal_name+="$(tr '[:lower:]' '[:upper:]' <<< "${part:0:1}")${part:1}"
    done

    # Build file paths
    local scene_dir script_dir test_dir
    if [[ "$dir_part" == "." ]]; then
        scene_dir="$PROJECT_ROOT/scenes"
        script_dir="$PROJECT_ROOT/scripts"
        test_dir="$PROJECT_ROOT/tests"
    else
        scene_dir="$PROJECT_ROOT/scenes/$dir_part"
        script_dir="$PROJECT_ROOT/scripts/$dir_part"
        test_dir="$PROJECT_ROOT/tests/$dir_part"
    fi

    local scene_file="$scene_dir/${name}.tscn"
    local script_file="$script_dir/${name}.gd"
    local test_file="$test_dir/test_${name}.gd"

    # Refuse to overwrite
    local conflict=false
    for f in "$scene_file" "$script_file" "$test_file"; do
        if [[ -f "$f" ]]; then
            err "File already exists: $f"
            conflict=true
        fi
    done
    if $conflict; then
        exit 1
    fi

    # Build res:// path for script reference
    local res_script_path
    if [[ "$dir_part" == "." ]]; then
        res_script_path="res://scripts/${name}.gd"
    else
        res_script_path="res://scripts/${dir_part}/${name}.gd"
    fi

    # Create directories
    mkdir -p "$scene_dir" "$script_dir" "$test_dir"

    # Write scene file
    cat > "$scene_file" <<TSCN
[gd_scene load_steps=2 format=3]

[ext_resource type="Script" path="${res_script_path}" id="1"]

[node name="${pascal_name}" type="${base_type}"]
script = ExtResource("1")
TSCN

    # Write script file
    cat > "$script_file" <<GDSCRIPT
extends ${base_type}
## TODO: describe ${pascal_name}.
GDSCRIPT

    # Write test file
    cat > "$test_file" <<GDTEST
extends GdUnitTestSuite
## Tests for ${pascal_name}.


func test_placeholder() -> void:
	assert_bool(true).is_true()
GDTEST

    ok "Created: $scene_file"
    ok "Created: $script_file"
    ok "Created: $test_file"
}

# ==================== new-test ====================
cmd_new_test() {
    if [[ $# -lt 1 ]]; then
        err "Usage: ror new-test <script.gd>"
        echo "  Example: ror new-test scripts/autoloads/resource_manager.gd"
        exit 1
    fi

    local source_path="$1"

    # Resolve relative to project root
    cd "$PROJECT_ROOT"

    # Validate source file exists
    if [[ ! -f "$source_path" ]]; then
        err "Source file not found: $source_path"
        exit 1
    fi

    # Validate it lives under scripts/
    if [[ "$source_path" != scripts/* ]]; then
        err "Source file must be under scripts/ (got: $source_path)"
        exit 1
    fi

    # Derive test path: scripts/foo/bar.gd -> tests/foo/test_bar.gd
    local rel_path="${source_path#scripts/}"
    local dir_part base test_dir test_path
    dir_part="$(dirname "$rel_path")"
    base="$(basename "$rel_path")"

    if [[ "$dir_part" == "." ]]; then
        test_dir="tests"
    else
        test_dir="tests/$dir_part"
    fi
    test_path="${test_dir}/test_${base}"

    # Refuse to overwrite existing test files
    if [[ -f "$test_path" ]]; then
        err "Test file already exists: $test_path"
        exit 1
    fi

    # Extract class_name (if declared) or derive PascalCase from filename
    local class_name=""
    class_name=$(grep -m1 '^class_name ' "$source_path" | sed 's/^class_name //' | tr -d '[:space:]' || true)
    if [[ -z "$class_name" ]]; then
        # Convert snake_case filename to PascalCase
        local name_no_ext="${base%.gd}"
        class_name=""
        IFS='_' read -ra parts <<< "$name_no_ext"
        for part in "${parts[@]}"; do
            class_name+="$(tr '[:lower:]' '[:upper:]' <<< "${part:0:1}")${part:1}"
        done
    fi

    # Extract public function names (lines starting with "func " where the
    # function name does NOT begin with "_")
    local -a funcs=()
    while IFS= read -r line; do
        # Extract function name from "func name(..." pattern
        local fname
        fname=$(echo "$line" | sed -n 's/^func \([a-zA-Z][a-zA-Z0-9_]*\).*/\1/p')
        if [[ -n "$fname" ]]; then
            funcs+=("$fname")
        fi
    done < <(grep '^func [^_]' "$source_path")

    # Create intermediate directories
    mkdir -p "$test_dir"

    # Write the test file
    {
        printf 'extends GdUnitTestSuite\n'
        printf '## Tests for %s.\n' "$class_name"

        if [[ ${#funcs[@]} -eq 0 ]]; then
            printf '\n\n'
            printf 'func test_placeholder() -> void:\n'
            printf '\tassert_bool(true).is_true()\n'
        else
            for fname in "${funcs[@]}"; do
                printf '\n\n'
                printf 'func test_%s() -> void:\n' "$fname"
                printf '\tassert_bool(true).is_true()\n'
            done
        fi
    } > "$test_path"

    ok "Created: $test_path"
    info "Found ${#funcs[@]} public function(s) in $source_path"
    if [[ ${#funcs[@]} -gt 0 ]]; then
        for fname in "${funcs[@]}"; do
            printf "  test_%s\n" "$fname"
        done
    fi
}

# ==================== help ====================
cmd_help() {
    cat <<EOF
${BOLD}ror${RESET} — Roots of Reason developer CLI

${BOLD}USAGE${RESET}
  ror <command> [options]

${BOLD}COMMANDS${RESET}
  test [path...]      Run GdUnit4 tests (headless)
                        ror test                    — run all tests
                        ror test tests/autoloads/   — run a subset
  lint [--fix] [path] Run gdlint + gdformat check
                        ror lint                    — check scripts/ tests/
                        ror lint --fix              — auto-format then lint
  scaffold <path/name> [--type Node2D]
                      Create scene + script + test boilerplate
                        ror scaffold map/pathfinder
                        ror scaffold ui/minimap --type Control
  new-test <script.gd> Generate a GdUnit4 test file for a source script
                        ror new-test scripts/autoloads/resource_manager.gd
  coverage [options]  Test-file coverage gate
                        ror coverage                — check at 90% threshold
                        ror coverage --threshold 90 — custom threshold
                        ror coverage --json         — machine-readable output
  help                Show this help message

${BOLD}ENVIRONMENT${RESET}
  GODOT_BIN           Path to Godot binary (auto-detected if unset)
EOF
}

# ==================== main ====================
case "${1:-help}" in
    test)     shift; cmd_test "$@" ;;
    lint)     shift; cmd_lint "$@" ;;
    scaffold) shift; cmd_scaffold "$@" ;;
    new-test) shift; cmd_new_test "$@" ;;
    coverage) shift; cmd_coverage "$@" ;;
    help|--help|-h) cmd_help ;;
    *)
        err "Unknown command: $1"
        cmd_help
        exit 1
        ;;
esac
